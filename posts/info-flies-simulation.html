<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Information Flies — Emoji Attractors & Repellents</title>
  <meta name="description" content="Place emoji concepts as attractors or repellents; watch flies move and pass information with finite speed." />
  <link rel="stylesheet" href="../style.css" />
  <style>
    html, body { height: 100%; }
    body { margin: 0; background: #fff; }
    .sim-root { position: fixed; inset: 0; display: grid; grid-template-rows: 1fr; }
    .toolbar { display: none; }
    .tool-group { display: flex; align-items: center; gap: 6px; }
    .tool-label { font-size: 14px; color: var(--muted); }
    .tool-btn { padding: 6px 10px; border: 1px solid var(--border); background: #fff; border-radius: 8px; cursor: pointer; font-size: 18px; line-height: 1; position: relative; }
    .tool-btn.active { outline: 2px solid var(--accent); }
    .tool { display: inline-flex; align-items: center; gap: 6px; }
    .tool input[type=range] { width: 120px; }
    .tool small { color: var(--muted); }
    #canvas { width: 100%; height: 100%; display: block; background: #ffffff; cursor: crosshair; }
    .hud { position: fixed; left: 12px; bottom: 12px; background: rgba(255,255,255,0.95); border: 1px solid var(--border); padding: 10px 12px; border-radius: 10px; font-size: 12px; color: var(--text); }
    .legend { color: var(--muted); font-size: 12px; }
    /* Emoji button color cues (channel + valence) */
    /* Flag buttons as colored blocks */
    /* House buttons */
    .tool-btn[data-house] { font-size: 12px; font-weight: 700; color:#fff; }
    .tool-btn[data-house="stark"] { background:#6b7280; border-color:#4b5563; }
    .tool-btn[data-house="lannister"] { background:#b91c1c; border-color:#991b1b; }
    .tool-btn[data-house="targaryen"] { background:#111827; border-color:#1f2937; }
    .tool-btn[data-house="tyrell"] { background:#065f46; border-color:#065f46; }
    .tool-btn[data-house="walkers"] { background:#3b82f6; border-color:#2563eb; }
    .tool-btn[data-house="wildfire"] { background:#10b981; border-color:#059669; }
    /* Collapsible math panel */
    .panel.math { position: fixed; right: 12px; top: 12px; width: 380px; max-width: 92vw; z-index: 20; }
    .panel.collapsed { height: 48px; overflow: hidden; }
    .panel.collapsed .panel-content { display: none; }
    /* Controls panel */
    .panel.controls { position: fixed; left: 12px; top: 12px; width: 480px; max-width: 96vw; z-index: 20; }
    .controls .grid { display: grid; grid-template-columns: 1fr; gap: 10px; }
    .controls .row { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .controls .row small { color: var(--muted); width: 80px; flex:0 0 auto; }
    .controls input[type=range] { width: 240px; flex: 1 1 auto; }
    .panel-content { padding: 12px 16px 16px 16px; max-height: 70vh; overflow: auto; }
    @media (max-width: 600px){
      .panel.controls { width: 96vw; left: 2vw; }
      .controls input[type=range]{ width: 55vw; }
    }
    .tabs { display:flex; gap:8px; margin: 8px 0; }
    .tab-btn { padding:6px 10px; border:1px solid var(--border); background:#fff; border-radius:8px; cursor:pointer; font-size:12px; }
    .tab-btn.active { outline:2px solid var(--accent); }
    .tab-section { display:none; }
    .tab-section.active { display:block; }
    /* Tooltip and legend */
    .flag-tip { position: fixed; pointer-events: none; background: rgba(0,0,0,0.8); color:#fff; font-size:12px; padding:6px 8px; border-radius:6px; border:1px solid rgba(255,255,255,0.2); z-index: 30; display:none; }
    .legend-mini { position: fixed; right: 12px; bottom: 12px; background: rgba(255,255,255,0.95); border:1px solid var(--border); padding:8px 10px; border-radius:8px; font-size:12px; color:var(--text); }
    .legend-row { display:flex; align-items:center; gap:8px; }
    .swatch { width:10px; height:10px; border-radius:2px; display:inline-block; }
    .swatch.red{ background:#e44242; }
    .swatch.blue{ background:#3b82f6; }
    .swatch.white{ background:#f3f4f6; border:1px solid #e5e7eb; }
  </style>
  <script>
    // Guard against duplicate custom element registrations from third‑party overlays
    (function(){
      try {
        if (window.customElements && typeof window.customElements.define === 'function') {
          const reg = window.customElements;
          const _define = reg.define.bind(reg);
          reg.define = function(name, ctor, options){
            if (reg.get && reg.get(name)) { return; }
            return _define(name, ctor, options);
          };
        }
      } catch (_) { /* no-op */ }
    })();
  </script>
  <script>
    window.MathJax = {
      tex: { inlineMath: [['$', '$'], ['\\(', '\\)']], displayMath: [['$$', '$$'], ['\\[', '\\]']] },
      options: { skipHtmlTags: ['script','noscript','style','textarea','pre'] }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
  <div class="sim-root">
    <canvas id="canvas"></canvas>
  </div>
  <div class="panel controls" id="controlsPanel">
    <div class="panel-header" id="controlsHeader">
      <span class="panel-title">Controls</span>
      <button class="panel-toggle" id="controlsToggle">▼</button>
    </div>
    <div class="panel-content" id="controlsContent">
      <div class="tabs">
        <button class="tab-btn active" id="tabTools">Tools</button>
        <button class="tab-btn" id="tabSettings">Settings</button>
      </div>
      <div class="tab-section active" id="toolsSection">
        <div class="grid">
          <div>
          <div class="tool-label" style="margin-bottom:6px;">Houses (Attractors)</div>
          <div class="tool-group" style="flex-wrap:wrap; gap:6px;">
            <button class="tool-btn" data-house="stark" title="House Stark">Stark</button>
            <button class="tool-btn" data-house="lannister" title="House Lannister">Lannister</button>
            <button class="tool-btn" data-house="targaryen" title="House Targaryen">Targaryen</button>
            <button class="tool-btn" data-house="tyrell" title="House Tyrell">Tyrell</button>
          </div>
          <div class="tool-label" style="margin:10px 0 6px 0;">Hazards (Repellents)</div>
          <div class="tool-group" style="flex-wrap:wrap; gap:6px;">
            <button class="tool-btn" data-house="walkers" title="White Walkers">Walkers</button>
            <button class="tool-btn" data-house="wildfire" title="Wildfire">Wildfire</button>
          </div>
            <div class="tool-group" style="margin-top:8px;">
              <span class="tool-label">Mode</span>
              <button class="tool-btn" id="modeAdd">Add</button>
              <button class="tool-btn" id="modeRemove">Remove</button>
            </div>
          </div>
          <div>
            <div class="tool-group" style="margin-top:0; gap:8px;">
              <button class="btn-secondary tool-btn" id="toggleMath">Math</button>
              <button class="btn-secondary tool-btn" id="togglePause">Pause</button>
              <button class="btn-secondary tool-btn" id="resetSettings">Reset</button>
              <button class="btn-secondary tool-btn" id="clear">Clear</button>
              <a href="../index.html" class="btn-secondary tool-btn">Home</a>
            </div>
          </div>
        </div>
      </div>
      <div class="tab-section" id="settingsSection">
        <div class="grid">
          <div>
            <div class="row"><small>Flies</small><input id="flies" type="range" min="60" max="500" step="10" value="220" /><small id="fliesV">220</small></div>
            <div class="row"><small>Flag Force</small><input id="attr" type="range" min="0" max="300" step="1" value="140" /><small id="attrV">140</small></div>
            <div class="row"><small>Comm</small><input id="comm" type="range" min="20" max="260" step="1" value="110" /><small id="commV">110</small></div>
            <div class="row"><small>Cohesion</small><input id="cohesion" type="range" min="0" max="200" step="2" value="36" /><small id="cohesionV">36</small></div>
          </div>
          <div>
            <div class="row"><small>Influence</small><input id="info" type="range" min="0" max="4" step="0.05" value="1.2" /><small id="infoV">1.20</small></div>
            <div class="row"><small>Forget</small><input id="forget" type="range" min="0" max="2" step="0.02" value="0.18" /><small id="forgetV">0.18</small></div>
            <div class="row"><small>Social</small><input id="social" type="range" min="0" max="200" step="2" value="72" /><small id="socialV">72</small></div>
            <div class="row"><small>Separation</small><input id="separation" type="range" min="0" max="300" step="2" value="120" /><small id="separationV">120</small></div>
            <div class="row"><small>SepDist</small><input id="sepDist" type="range" min="5" max="80" step="1" value="28" /><small id="sepDistV">28</small></div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div class="hud" id="hud"></div>
  <div class="legend-mini" id="legendMini"></div>
  <div class="panel math collapsed" id="mathPanel">
    <div class="panel-header" id="mathHeader">
      <span class="panel-title">Flag Influence — Model</span>
      <button class="panel-toggle" id="mathToggle">▼</button>
    </div>
    <div class="panel-content">
      <div class="article-content" style="font-size:14px;">
        <p>We place control flags $k$ (red/blue/white) in the plane. Each fly $i$ carries an allegiance label $L_i$ (the flag it follows)
        and a scalar influence strength $s_i \in [0,1]$ (neutral if $s_i \approx 0$). Physics couples motion, sensing, and local communication.</p>
        <p>Motion (with damping):</p>
        $$\dot x_i = v_i,\quad \dot v_i = \sum_k F_k(x_i,L_i,s_i) - \gamma v_i$$
        where the flag force near flag $k$ is attractive and scales with allegiance:
        $$F_k \propto \frac{\alpha(L_i,k,s_i)}{\|x_i-x_k\|^2}\, \frac{x_k - x_i}{\|x_k-x_i\|},\qquad
          \alpha = \begin{cases}
          \alpha_0 & L_i<0 \text{ (neutral: stronger bias)}\\
          \alpha_1(0.8+0.4s_i) & L_i=k \text{ (follow own flag)}\\
          \alpha_2 & L_i\neq k \text{ (weak cross-bias)}
          \end{cases} $$
        <p>Sensing and forgetting:</p>
        $$\dot s_i = \eta\,\sigma(\|x_i-x_{L_i}\|) - \lambda s_i,$$
        where $\sigma$ increases near a flag; neutral flies adopt the nearest flag on contact.</p>
        <p>Local communication (label propagation):</p>
        $$\dot s_i \mathrel{+}= \sum_j w_{ij}(s_j - s_i),\qquad
          L_i \leftarrow L_j \text{ if } s_j > s_i,$$
        with $w_{ij}=\phi(\|x_i-x_j\|)\,\psi(\|v_i-v_j\|)$ decaying with distance and relative speed.
        <p>Social terms (cohesion/separation/alignment) are awareness-weighted so informed flies coordinate flocks while neutrals seek flags.</p>
      </div>
    </div>
  </div>

  <script>
  (function(){
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let W=0, H=0, DPR=Math.max(1, Math.min(2, window.devicePixelRatio||1));
    const rand = (a,b)=>Math.random()*(b-a)+a;
    const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
    const dist2=(ax,ay,bx,by)=>{const dx=ax-bx,dy=ay-by;return dx*dx+dy*dy;};

    const state = {
      flies: [], // {x,y,vx,vy,info:[r,g,b], allegiance:-1, s:0}
      objs: [],  // {x,y,emoji,type:'flag', color?:'red'|'blue'|'white', qty?, maxQty?}
      grid: null, // spatial hash
      params: { N:220, kFlag:140, commR:110, influence:1.2, speed:42, forget:0.18, social:72, cohesion:36, separation:120, sepDist:28 },
      paused:false,
      tool: { flag:'red', mode:'add' },
    };

    // no legacy emoji mapping

    function resize(){
      W = canvas.clientWidth = window.innerWidth;
      H = canvas.clientHeight = window.innerHeight;
      canvas.width = Math.floor(W*DPR); canvas.height = Math.floor(H*DPR);
      canvas.style.width = W+'px'; canvas.style.height = H+'px';
      ctx.setTransform(DPR,0,0,DPR,0,0);
    }

    function initFlies(N){
      state.flies.length = 0;
      for(let i=0;i<N;i++){
        const x = Math.random()*W, y = Math.random()*H;
        const ang = rand(-Math.PI,Math.PI), sp=state.params.speed;
        state.flies.push({ x, y, vx: Math.cos(ang)*sp, vy: Math.sin(ang)*sp, info:[0,0,0], allegiance:-1, s:0 });
      }
    }

    // Defaults for reset
    const defaultParams = { N:220, kAttr:140, kRepel:180, commR:110, infoRate:1.2, speed:42, forget:0.18, beta:0.8, social:72, cohesion:36, separation:120, sepDist:28, hazardAlpha:1.2 };

    const HOUSES = {
      stark:      { type:'attractor', idx:1, color:'#6b7280', name:'Stark' },
      lannister:  { type:'attractor', idx:0, color:'#b91c1c', name:'Lannister' },
      targaryen:  { type:'attractor', idx:2, color:'#111827', name:'Targaryen' },
      tyrell:     { type:'attractor', idx:1, color:'#065f46', name:'Tyrell' },
      walkers:    { type:'repellent', idx:2, color:'#3b82f6', name:'Walkers' },
      wildfire:   { type:'repellent', idx:1, color:'#10b981', name:'Wildfire' },
    };

    function addObject(x,y,house){
      const h=HOUSES[house]||HOUSES.stark;
      state.objs.push({x,y,type:h.type, idx:h.idx, color:h.color, name:h.name});
    }

    function removeNearestObject(x,y){
      if(!state.objs.length) return;
      let best=-1, bd=1e9;
      for(let i=0;i<state.objs.length;i++){
        const o=state.objs[i]; const d=dist2(x,y,o.x,o.y);
        if(d<bd){ bd=d; best=i; }
      }
      if(best>=0) state.objs.splice(best,1);
    }

    // Spatial hash for comm links
    function buildGrid(cell=80){
      const cols=Math.max(1, Math.ceil((W||1)/cell)), rows=Math.max(1, Math.ceil((H||1)/cell));
      const g=Array.from({length:cols*rows},()=>[]);
      const idx=(x,y)=> clamp(Math.floor(x/cell),0,cols-1)+cols*clamp(Math.floor(y/cell),0,rows-1);
      for(let i=0;i<state.flies.length;i++){ const f=state.flies[i]; g[idx(f.x,f.y)].push(i); }
      state.grid={g,cell,cols,rows,idx};
    }

    function neighbors(i){
      const {g,cell,cols,rows,idx} = state.grid; const f=state.flies[i];
      const cx=clamp(Math.floor(f.x/cell),0,cols-1), cy=clamp(Math.floor(f.y/cell),0,rows-1);
      const res=[];
      for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++){
        const X=cx+dx, Y=cy+dy; if(X<0||Y<0||X>=cols||Y>=rows) continue;
        res.push(...g[X+cols*Y]);
      }
      return res;
    }

    function parallelTransport(info, vx, vy, dt, speed){
      const v = Math.hypot(vx,vy); if (v<1e-3) return;
      const a = Math.atan2(vy,vx);
      const s = Math.min(1, v/Math.max(1,speed));
      const theta = 0.7 * s * dt; // mixing rate
      // skew-symmetric generator coefficients (velocity-dependent)
      const a1 = 0.9*Math.cos(a), a2=0.9*Math.sin(a), a3=0.6*Math.cos(2*a);
      const r=info[0], g=info[1], b=info[2];
      // d(info) = theta * G * info
      const dr = theta * ( -a1*g + a2*b);
      const dg = theta * (  a1*r - a3*b);
      const db = theta * ( -a2*r + a3*g);
      info[0]=clamp(r+dr,-1,1); info[1]=clamp(g+dg,-1,1); info[2]=clamp(b+db,-1,1);
    }

    function step(dt){
      const {kAttr,kRepel,commR,infoRate,speed,forget,beta,social,cohesion,separation,sepDist,hazardAlpha} = state.params;
      const commR2 = commR*commR;
      const N = state.flies.length; const ax = new Float32Array(N), ay = new Float32Array(N);
      // forgetting and object forces with hazard dominance
      for(let i=0;i<N;i++){
        const f = state.flies[i];
        // forget
        f.info[0] = Math.max(-1, Math.min(1, f.info[0] - forget*f.info[0]*dt));
        f.info[1] = Math.max(-1, Math.min(1, f.info[1] - forget*f.info[1]*dt));
        f.info[2] = Math.max(-1, Math.min(1, f.info[2] - forget*f.info[2]*dt));
        let axAttr=0, ayAttr=0, axRep=0, ayRep=0, attrSum=0, repSum=0;
        for(const o of state.objs){
          const dx=o.x-f.x, dy=o.y-f.y; const r2=dx*dx+dy*dy+25; const r=Math.sqrt(r2);
          const idx = o.idx;
          const reactSign = (o.type==='attractor')? 1 : -1;
          const sensScale = 1 + beta * (f.info[idx]||0) * reactSign;
          if (o.type==='attractor'){
            const mag = sensScale * (kAttr / r2);
            axAttr += mag * dx / r; ayAttr += mag * dy / r; attrSum += (kAttr / r2);
          } else {
            const mag = sensScale * (kRepel / r2);
            axRep += -mag * dx / r; ayRep += -mag * dy / r; repSum += (kRepel / r2);
          }
          // sensing update
          if (r<60){ const sgn = (o.type==='attractor')? 1 : -1; const v=(f.info[idx]||0) + sgn * 1.2*dt; f.info[idx] = Math.max(-1, Math.min(1, v)); }
        }
        const risk = repSum / (attrSum + 1e-6);
        const scaleA = 1/(1 + hazardAlpha * risk);
        const scaleR = 1 + hazardAlpha * risk;
        ax[i] += axAttr * scaleA + axRep * scaleR;
        ay[i] += ayAttr * scaleA + ayRep * scaleR;
      }
      // communication + social alignment
      buildGrid();
      const maxLinks=120; let drawn=0;
      for(let i=0;i<N;i++){
        const f = state.flies[i]; const vfi = Math.hypot(f.vx,f.vy)||1e-6; const ufi=[f.vx/vfi, f.vy/vfi];
        const neigh = neighbors(i);
        for(const j of neigh){ if(j<=i) continue; const g=state.flies[j];
          const d2 = (f.x-g.x)*(f.x-g.x)+(f.y-g.y)*(f.y-g.y); if(d2>commR2) continue; const d=Math.sqrt(d2);
          const phi = 1 - d/commR; if (phi<=0) continue;
          const vrel = Math.hypot(f.vx-g.vx, f.vy-g.vy);
          const psi = 1/(1+vrel/40);
          const k = infoRate * phi * psi;
          const dr = ((g.info[0]||0)-(f.info[0]||0)) * k * dt;
          const dg = ((g.info[1]||0)-(f.info[1]||0)) * k * dt;
          const db = ((g.info[2]||0)-(f.info[2]||0)) * k * dt;
          f.info[0]=Math.max(-1, Math.min(1, (f.info[0]||0)+dr)); g.info[0]=Math.max(-1, Math.min(1, (g.info[0]||0)-dr));
          f.info[1]=Math.max(-1, Math.min(1, (f.info[1]||0)+dg)); g.info[1]=Math.max(-1, Math.min(1, (g.info[1]||0)-dg));
          f.info[2]=Math.max(-1, Math.min(1, (f.info[2]||0)+db)); g.info[2]=Math.max(-1, Math.min(1, (g.info[2]||0)-db));
          const infG = Math.max(Math.abs(g.info[0]||0), Math.abs(g.info[1]||0), Math.abs(g.info[2]||0));
          const infF = Math.max(Math.abs(f.info[0]||0), Math.abs(f.info[1]||0), Math.abs(f.info[2]||0));
          const w = social * phi * psi * 0.5;
          const vgj = Math.hypot(g.vx,g.vy)||1e-6; const ugj=[g.vx/vgj, g.vy/vgj];
          ax[i] += (ugj[0]-ufi[0]) * w * infG; ay[i] += (ugj[1]-ufi[1]) * w * infG;
          ax[j] += (ufi[0]-ugj[0]) * w * infF; ay[j] += (ufi[1]-ugj[1]) * w * infF;
          if (drawn<maxLinks){
            const mr = Math.abs(f.info[0]-g.info[0]);
            const mg = Math.abs(f.info[1]-g.info[1]);
            const mb = Math.abs(f.info[2]-g.info[2]);
            const alpha = 0.05 + 0.2*Math.max(mr,mg,mb);
            ctx.save(); ctx.globalAlpha = alpha;
            ctx.strokeStyle = `rgb(${Math.floor(200*mr)}, ${Math.floor(200*mg)}, ${Math.floor(200*mb)})`;
            ctx.beginPath(); ctx.moveTo(f.x,f.y); ctx.lineTo(g.x,g.y); ctx.stroke(); ctx.restore();
            drawn++;
          }
        }
      }
      // boids-style cohesion and separation (awareness weighted)
      for(let i=0;i<N;i++){
        const f = state.flies[i];
        const neigh = neighbors(i);
        let cx=0, cy=0, wsum=0; // cohesion
        let sx=0, sy=0;        // separation
        for(const j of neigh){ if(j===i) continue; const g=state.flies[j];
          const dx=g.x-f.x, dy=g.y-f.y; const d2=dx*dx+dy*dy; const d=Math.sqrt(d2)+1e-6;
          const phi = Math.max(0, 1 - d/commR);
          const inf = Math.max(Math.abs(g.info[0]||0), Math.abs(g.info[1]||0), Math.abs(g.info[2]||0));
          const w = phi * (0.5+0.5*inf);
          cx += g.x * w; cy += g.y * w; wsum += w;
          const sep = Math.max(0, sepDist - d);
          if (sep>0){ sx += -(dx/d) * (sep*sep/d); sy += -(dy/d) * (sep*sep/d); }
        }
        if (wsum>0){
          const tx = (cx/wsum) - f.x; const ty = (cy/wsum) - f.y;
          ax[i] += cohesion * tx * 0.0015;
          ay[i] += cohesion * ty * 0.0015;
        }
        ax[i] += separation * sx * 0.0025;
        ay[i] += separation * sy * 0.0025;
      }
      // integrate
      for(let i=0;i<N;i++){
        const f=state.flies[i];
        f.vx = Math.max(-160, Math.min(160, f.vx + ax[i]*dt));
        f.vy = Math.max(-160, Math.min(160, f.vy + ay[i]*dt));
        parallelTransport(f.info, f.vx, f.vy, dt, speed);
        const v=Math.hypot(f.vx,f.vy)||1; const vmax=speed;
        if(v>vmax){ f.vx=f.vx/v*vmax; f.vy=f.vy/v*vmax; }
        f.x += f.vx*dt; f.y += f.vy*dt;
        if (f.x<4){ f.x=4; f.vx=Math.abs(f.vx); }
        if (f.x>W-4){ f.x=W-4; f.vx=-Math.abs(f.vx); }
        if (f.y<4){ f.y=4; f.vy=Math.abs(f.vy); }
        if (f.y>H-4){ f.y=H-4; f.vy=-Math.abs(f.vy); }
      }
    }

    function draw(){
      ctx.clearRect(0,0,W,H);
      // objects
      for(const o of state.objs){
        ctx.save(); ctx.font = '20px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
        // no heatmap for flags
        // draw a simple flag (pole + colored banner)
        const col = (o.color==='red')? '#e44242' : (o.color==='blue')? '#3b82f6' : '#f3f4f6';
        const w=28, h=16, pole=10;
        ctx.globalAlpha=1; ctx.strokeStyle='#888'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(o.x-pole, o.y-h/2); ctx.lineTo(o.x-pole, o.y+h/2+6); ctx.stroke();
        ctx.fillStyle=col; ctx.strokeStyle='#222'; ctx.lineWidth=1;
        ctx.beginPath(); ctx.rect(o.x-pole+2, o.y-h/2, w, h); ctx.fill(); ctx.stroke();
        ctx.restore();
      }
      // flies with info dots (RGB) and direction hint
      for(const f of state.flies){
        // body
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.beginPath(); ctx.arc(f.x, f.y, 3.8, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.lineWidth = 0.6; ctx.stroke();
        // direction hint
        const vmag = Math.hypot(f.vx,f.vy);
        if (vmag>1e-2){
          const ux=f.vx/vmag, uy=f.vy/vmag; const L=7;
          const a0=Math.abs(f.info[0]||0), a1=Math.abs(f.info[1]||0), a2=Math.abs(f.info[2]||0);
          let kdom=0, ad=a0; if(a1>ad){kdom=1; ad=a1;} if(a2>ad){kdom=2; ad=a2;}
          const cols=[[230,40,30],[30,150,60],[40,90,220]]; const c=cols[kdom];
          ctx.strokeStyle = `rgba(${c[0]},${c[1]},${c[2]},${0.25+0.45*ad})`;
          ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(f.x, f.y); ctx.lineTo(f.x+ux*L, f.y+uy*L); ctx.stroke();
        }
        // info dots around
        const R=5.6;
        const angs=[-Math.PI/2, -Math.PI/2 + 2*Math.PI/3, -Math.PI/2 + 4*Math.PI/3];
        const cols=[[230,40,30],[30,150,60],[40,90,220]]; // R,G,B
        for(let k=0;k<3;k++){
          const a=angs[k]; const x=f.x+R*Math.cos(a), y=f.y+R*Math.sin(a);
          const val = Math.abs(f.info[k]||0);
          const s=1.2+2.2*val;
          const c=cols[k]; ctx.fillStyle=`rgba(${c[0]},${c[1]},${c[2]},${0.25+0.6*val})`;
          if ((f.info[k]||0) < 0){ ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.lineWidth=0.8; } else { ctx.strokeStyle='rgba(255,255,255,0.5)'; ctx.lineWidth=0.5; }
          ctx.beginPath(); ctx.arc(x,y, s, 0, Math.PI*2); ctx.fill();
          ctx.stroke();
        }
      }
    }

    // HUD
    function hud(){
      const el=document.getElementById('hud');
      // mean info vector
      let mr=0,mg=0,mb=0; for(const f of state.flies){ mr+=f.info[0]; mg+=f.info[1]; mb+=f.info[2]; }
      const n=state.flies.length||1; mr/=n; mg/=n; mb/=n;
      const concept = state.tool.emoji;
      el.innerHTML = `flies=${state.flies.length} • objs=${state.objs.length} • mean q=[${mr.toFixed(2)}, ${mg.toFixed(2)}, ${mb.toFixed(2)}]`+
                     `<div class="legend">Click to ${state.tool.mode==='add'?'place':'remove'} ${concept}. Shift-click always removes.</div>`;
    }

    // Interaction
    function pickHouse(btn){
      document.querySelectorAll('.tool-btn[data-house]').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      state.tool.house = btn.getAttribute('data-house');
    }
    document.querySelectorAll('.tool-btn[data-house]').forEach(btn=>{
      btn.addEventListener('click', ()=> pickHouse(btn));
    });
    pickHouse(document.querySelector('.tool-btn[data-house="stark"]'));
    const modeAdd=document.getElementById('modeAdd');
    const modeRemove=document.getElementById('modeRemove');
    function setMode(m){ state.tool.mode=m; modeAdd.classList.toggle('active', m==='add'); modeRemove.classList.toggle('active', m==='remove'); }
    modeAdd.addEventListener('click', ()=>setMode('add'));
    modeRemove.addEventListener('click', ()=>setMode('remove'));
    setMode('add');

    canvas.addEventListener('click', (e)=>{
      const r=canvas.getBoundingClientRect(); const x=(e.clientX-r.left), y=(e.clientY-r.top);
      if (e.shiftKey || state.tool.mode==='remove') removeNearestObject(x,y);
      else addObject(x,y,state.tool.house);
    });

    // Controls
    function bindRange(id, prop, fmt=(v)=>v){
      const el=document.getElementById(id); const lab=document.getElementById(id+'V');
      function upd(){ state.params[prop] = (id==='info'? parseFloat(el.value) : +el.value); lab.textContent = fmt(state.params[prop]); }
      el.addEventListener('input', ()=>{ upd(); if(prop==='N'){ initFlies(state.params.N); } });
      upd();
    }
    bindRange('flies','N');
    bindRange('attr','kAttr');
    bindRange('comm','commR');
    bindRange('info','infoRate', v=>v.toFixed(2));
    bindRange('forget','forget', v=>v.toFixed(2));
    bindRange('social','social');
    bindRange('cohesion','cohesion');
    bindRange('separation','separation');
    bindRange('sepDist','sepDist');

    document.getElementById('togglePause').addEventListener('click', ()=>{ state.paused=!state.paused; document.getElementById('togglePause').textContent = state.paused?'Resume':'Pause'; });
    document.getElementById('clear').addEventListener('click', ()=>{ state.objs.length=0; state.flies.forEach(f=>{ f.info[0]=0; f.info[1]=0; f.info[2]=0; f.s=0; f.allegiance=-1; }); });
    // reset defaults
    document.getElementById('resetSettings').addEventListener('click', ()=>{
      const set=(id,val)=>{ const el=document.getElementById(id); if(!el) return; el.value=String(val); el.dispatchEvent(new Event('input',{bubbles:true})); };
      const d= { N:220, kFlag:140, commR:110, influence:1.2, speed:42, forget:0.18, social:72, cohesion:36, separation:120, sepDist:28 };
      set('flies', d.N); set('attr', d.kFlag); set('comm', d.commR); set('info', d.influence); set('forget', d.forget);
      set('social', d.social); set('cohesion', d.cohesion); set('separation', d.separation); set('sepDist', d.sepDist);
      saveSettings();
    });
    // math panel toggle
    const mathPanel=document.getElementById('mathPanel');
    function toggleMath(){ mathPanel.classList.toggle('collapsed'); }
    document.getElementById('mathToggle').addEventListener('click', toggleMath);
    document.getElementById('mathHeader').addEventListener('click', toggleMath);
    document.getElementById('toggleMath').addEventListener('click', toggleMath);
    // controls panel + tabs
    const controlsPanel=document.getElementById('controlsPanel');
    document.getElementById('controlsToggle').addEventListener('click', ()=> controlsPanel.classList.toggle('collapsed'));
    document.getElementById('controlsHeader').addEventListener('click', ()=> controlsPanel.classList.toggle('collapsed'));
    const tabTools=document.getElementById('tabTools');
    const tabSettings=document.getElementById('tabSettings');
    const toolsSection=document.getElementById('toolsSection');
    const settingsSection=document.getElementById('settingsSection');
    function setTab(which){
      const tools = which==='tools';
      tabTools.classList.toggle('active', tools);
      tabSettings.classList.toggle('active', !tools);
      toolsSection.classList.toggle('active', tools);
      settingsSection.classList.toggle('active', !tools);
    }
    tabTools.addEventListener('click', ()=> setTab('tools'));
    tabSettings.addEventListener('click', ()=> setTab('settings'));
    setTab('tools');

    // Persist settings
    function saveSettings(){
      try{
        const p=state.params; const data={ N:p.N,kFlag:p.kFlag,commR:p.commR,influence:p.influence,speed:p.speed,forget:p.forget,social:p.social,cohesion:p.cohesion,separation:p.separation,sepDist:p.sepDist };
        localStorage.setItem('infoflies.settings', JSON.stringify(data));
      }catch(e){}
    }
    function loadSettings(){
      try{
        const raw=localStorage.getItem('infoflies.settings'); if(!raw) return; const d=JSON.parse(raw);
        const set=(id,val)=>{ const el=document.getElementById(id); if(!el) return; el.value=String(val); el.dispatchEvent(new Event('input',{bubbles:true})); };
        for(const [id,key] of [['flies','N'],['attr','kFlag'],['comm','commR'],['info','influence'],['forget','forget'],['social','social'],['cohesion','cohesion'],['separation','separation'],['sepDist','sepDist']]){
          if(d[key]!==undefined) set(id,d[key]);
        }
      }catch(e){}
    }
    // attach save to sliders
    document.querySelectorAll('#settingsSection input[type=range]').forEach(el=> el.addEventListener('input', saveSettings));
    loadSettings();

    // Loop
    let last=performance.now();
    function loop(now){
      const dt = Math.min(50, now-last)/1000; last=now;
      if(!state.paused){ step(dt); }
      draw(); hud(); updateLegend(); requestAnimationFrame(loop);
    }
    // Hover tooltip on flags
    const tip=document.createElement('div'); tip.id='flagTip'; tip.className='flag-tip'; document.body.appendChild(tip);
    canvas.addEventListener('mousemove', (e)=>{
      const r=canvas.getBoundingClientRect(); const mx=e.clientX-r.left, my=e.clientY-r.top;
      let best=-1, bd=900; for(let i=0;i<state.objs.length;i++){ const o=state.objs[i]; const d2=(o.x-mx)*(o.x-mx)+(o.y-my)*(o.y-my); if(d2<bd){ bd=d2; best=i; } }
      if (best>=0 && bd < 1600){
        const o=state.objs[best]; let aware=0; for(const f of state.flies){ const v=Math.abs(f.info[o.idx]||0); if(v>0.6) aware++; }
        tip.innerHTML = `${o.name} • channel ${o.idx} • aware: ${aware}`;
        tip.style.left = `${e.clientX+12}px`; tip.style.top = `${e.clientY+12}px`; tip.style.display='block';
      } else { tip.style.display='none'; }
    });
    function updateLegend(){
      const el=document.getElementById('legendMini'); if(!el) return;
      const C={red:{c:0,s:0}, blue:{c:0,s:0}, white:{c:0,s:0}, neutral:0};
      for(const f of state.flies){
        if (f.allegiance!=null && f.allegiance>=0 && state.objs[f.allegiance] && state.objs[f.allegiance].type==='flag'){
          const col=state.objs[f.allegiance].color||'red'; C[col].c++; C[col].s += (f.s||0);
        } else { C.neutral++; }
      }
      const avg=(x)=> x.c? (x.s/x.c).toFixed(2) : '0.00';
      el.innerHTML = `
        <div class="legend-row"><span class="swatch red"></span> Red: ${C.red.c} • s=${avg(C.red)}</div>
        <div class="legend-row"><span class="swatch blue"></span> Blue: ${C.blue.c} • s=${avg(C.blue)}</div>
        <div class="legend-row"><span class="swatch white"></span> White: ${C.white.c} • s=${avg(C.white)}</div>
        <div class="legend-row">Neutral: ${C.neutral}</div>
      `;
    }

    // Boot
    function start(){ resize(); initFlies(state.params.N); requestAnimationFrame(loop); }
    window.addEventListener('resize', ()=>{ resize(); });
    start();
  })();
  </script>
</body>
</html>
