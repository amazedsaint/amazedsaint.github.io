<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Information Flies — Emoji Attractors & Repellents</title>
  <meta name="description" content="Place emoji concepts as attractors or repellents; watch flies move and pass information with finite speed." />
  <link rel="stylesheet" href="../style.css" />
  <style>
    html, body { height: 100%; }
    body { margin: 0; background: #fff; }
    .sim-root { position: fixed; inset: 0; display: grid; grid-template-rows: 1fr; }
    .toolbar { display: none; }
    .tool-group { display: flex; align-items: center; gap: 6px; }
    .tool-label { font-size: 14px; color: var(--muted); }
    .tool-btn { padding: 6px 10px; border: 1px solid var(--border); background: #fff; border-radius: 8px; cursor: pointer; font-size: 18px; line-height: 1; position: relative; }
    .tool-btn.active { outline: 2px solid var(--accent); }
    .tool { display: inline-flex; align-items: center; gap: 6px; }
    .tool input[type=range] { width: 120px; }
    .tool small { color: var(--muted); }
    #canvas { width: 100%; height: 100%; display: block; background: #ffffff; cursor: crosshair; }
    .hud { position: fixed; left: 12px; bottom: 12px; background: rgba(255,255,255,0.95); border: 1px solid var(--border); padding: 10px 12px; border-radius: 10px; font-size: 12px; color: var(--text); }
    .legend { color: var(--muted); font-size: 12px; }
    /* Emoji button color cues (channel + valence) */
    .tool-btn[data-emoji="🍎"], .tool-btn[data-emoji="🌶️"] { box-shadow: inset 0 0 0 2px rgba(230,40,30,0.25); }
    .tool-btn[data-emoji="🍊"] { box-shadow: inset 0 0 0 2px rgba(30,150,60,0.25); }
    .tool-btn[data-emoji="📣"], .tool-btn[data-emoji="💀"] { box-shadow: inset 0 0 0 2px rgba(40,90,220,0.25); }
    .tool-btn[data-emoji]::after { content:""; width:8px; height:8px; border-radius:50%; position:absolute; right:6px; top:6px; }
    .tool-btn[data-emoji="🍎"]::after { background: rgb(230,40,30); }
    .tool-btn[data-emoji="🍊"]::after { background: rgb(30,150,60); }
    .tool-btn[data-emoji="📣"]::after { background: rgb(40,90,220); }
    .tool-btn[data-emoji="🌶️"]::after { background: rgb(230,40,30); }
    .tool-btn[data-emoji="💀"]::after { background: rgb(40,90,220); }
    /* Collapsible math panel */
    .panel.math { position: fixed; right: 12px; top: 64px; width: 380px; max-width: 92vw; z-index: 20; }
    .panel.collapsed { height: 48px; overflow: hidden; }
    .panel.collapsed .panel-content { display: none; }
    /* Controls panel */
    .panel.controls { position: fixed; right: 12px; bottom: 12px; width: 360px; max-width: 92vw; z-index: 20; }
    .controls .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .controls .row { display:flex; align-items:center; gap:8px; }
    .controls .row small { color: var(--muted); width: 64px; }
    .controls input[type=range] { width: 160px; }
  </style>
  <script>
    window.MathJax = {
      tex: { inlineMath: [['$', '$'], ['\\(', '\\)']], displayMath: [['$$', '$$'], ['\\[', '\\]']] },
      options: { skipHtmlTags: ['script','noscript','style','textarea','pre'] }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
  <div class="sim-root">
    <canvas id="canvas"></canvas>
  </div>
  <div class="panel controls" id="controlsPanel">
    <div class="panel-header" id="controlsHeader">
      <span class="panel-title">Controls</span>
      <button class="panel-toggle" id="controlsToggle">▼</button>
    </div>
    <div class="panel-content" id="controlsContent">
      <div class="grid">
        <div>
          <div class="tool-label" style="margin-bottom:6px;">Concept</div>
          <div class="tool-group" style="flex-wrap:wrap; gap:6px;">
            <button class="tool-btn" data-emoji="🍎" title="Apple (attractor)">🍎</button>
            <button class="tool-btn" data-emoji="🍊" title="Orange (attractor)">🍊</button>
            <button class="tool-btn" data-emoji="📣" title="Beacon (attractor)">📣</button>
            <button class="tool-btn" data-emoji="🌶️" title="Chili (repellent)">🌶️</button>
            <button class="tool-btn" data-emoji="💀" title="Hazard (repellent)">💀</button>
          </div>
          <div class="tool-group" style="margin-top:8px;">
            <span class="tool-label">Mode</span>
            <button class="tool-btn" id="modeAdd">Add</button>
            <button class="tool-btn" id="modeRemove">Remove</button>
          </div>
        </div>
        <div>
          <div class="row"><small>Flies</small><input id="flies" type="range" min="60" max="500" step="10" value="220" /><small id="fliesV">220</small></div>
          <div class="row"><small>Attract</small><input id="attr" type="range" min="0" max="240" step="1" value="120" /><small id="attrV">120</small></div>
          <div class="row"><small>Repel</small><input id="repel" type="range" min="0" max="240" step="1" value="140" /><small id="repelV">140</small></div>
          <div class="row"><small>Comm</small><input id="comm" type="range" min="20" max="220" step="1" value="100" /><small id="commV">100</small></div>
          <div class="row"><small>Info</small><input id="info" type="range" min="0" max="4" step="0.05" value="1.2" /><small id="infoV">1.20</small></div>
          <div class="row"><small>Forget</small><input id="forget" type="range" min="0" max="2" step="0.02" value="0.18" /><small id="forgetV">0.18</small></div>
          <div class="row"><small>Awareness β</small><input id="beta" type="range" min="0" max="0.99" step="0.01" value="0.8" /><small id="betaV">0.80</small></div>
          <div class="row"><small>Social</small><input id="social" type="range" min="0" max="180" step="2" value="64" /><small id="socialV">64</small></div>
        </div>
      </div>
      <div class="tool-group" style="margin-top:8px; gap:8px;">
        <button class="btn-secondary tool-btn" id="toggleMath">Math</button>
        <button class="btn-secondary tool-btn" id="togglePause">Pause</button>
        <button class="btn-secondary tool-btn" id="clear">Clear</button>
        <a href="../index.html" class="btn-secondary tool-btn">Home</a>
      </div>
    </div>
  </div>
  <div class="hud" id="hud"></div>
  <div class="panel math collapsed" id="mathPanel">
    <div class="panel-header" id="mathHeader">
      <span class="panel-title">SU(3) Info Transport — Model</span>
      <button class="panel-toggle" id="mathToggle">▼</button>
    </div>
    <div class="panel-content">
      <div class="article-content" style="font-size:14px;">
        <p>Each fly $i$ carries a simplified SU(3)-inspired information state $q_i \in \mathbb{R}^3$ ("color charges"),
        visualized as three color dots. The dynamics couple motion, sensing, and communication on the proximity graph.</p>
        <p>Motion:</p>
        $$\dot x_i = v_i,\quad \dot v_i = \sum_k F_k(x_i) - \gamma v_i$$
        <p>Parallel transport (gauge-like mixing along velocity):</p>
        $$\dot q_i = \theta(\|v_i\|)\,G(v_i)\,q_i$$
        where $G$ is skew-symmetric (an $\mathfrak{su}(3)$-inspired generator) and $\theta$ scales with speed.
        <p>Sensing (attractors/repellents indexed by $k$ and mapped to color basis $e_{c(k)}$):</p>
        $$\dot q_i \mathrel{+}= s_k\,\sigma(\|x_i-x_k\|)\, e_{c(k)} \quad (s_k=\pm1)$$
        <p>Graph information passing (finite-speed diffusion over a proximity graph $w_{ij}$):</p>
        $$\dot q_i \mathrel{+}= \sum_j w_{ij}\,(q_j - q_i),\quad w_{ij}=\phi(\|x_i-x_j\|)\,\psi(\|v_i-v_j\|)$$
        <p>Coupling of information to motion (awareness-driven sensitivity):</p>
        $$F_k^{\text{eff}}(q_i) = \bigl(1 + \beta\, s_k\, e_{c(k)}^\top q_i\bigr)\,F_k$$
        with $0\le \beta < 1$ so the sign of $F_k$ is preserved; positive alignment increases attraction (or repulsion), negative alignment diminishes it.
        <p>This is a pedagogical approximation: we visualize three components (RGB) rather than the full 8-dim $\mathfrak{su}(3)$ basis.</p>
      </div>
    </div>
  </div>

  <script>
  (function(){
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let W=0, H=0, DPR=Math.max(1, Math.min(2, window.devicePixelRatio||1));
    const rand = (a,b)=>Math.random()*(b-a)+a;
    const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
    const dist2=(ax,ay,bx,by)=>{const dx=ax-bx,dy=ay-by;return dx*dx+dy*dy;};

    const state = {
      flies: [], // {x,y,vx,vy,info:[r,g,b]}
      objs: [],  // {x,y,emoji,type:'attractor'|'repellent'}
      grid: null, // spatial hash
      params: { N:220, kAttr:120, kRepel:140, commR:100, infoRate:1.2, speed:42, forget:0.18, beta:0.8, social:64 },
      paused:false,
      tool: { emoji:'🍎', mode:'add' },
      emojiType: new Map([
        ['🍎','attractor'], ['🍊','attractor'], ['📣','attractor'], ['🌶️','repellent'], ['💀','repellent']
      ]),
    };

    const emojiColorIndex = new Map([
      ['🍎',0], ['🍊',1], ['📣',2], ['🌶️',0], ['💀',2]
    ]);

    function resize(){
      W = canvas.clientWidth = window.innerWidth;
      H = canvas.clientHeight = window.innerHeight;
      canvas.width = Math.floor(W*DPR); canvas.height = Math.floor(H*DPR);
      canvas.style.width = W+'px'; canvas.style.height = H+'px';
      ctx.setTransform(DPR,0,0,DPR,0,0);
    }

    function initFlies(N){
      state.flies.length = 0;
      for(let i=0;i<N;i++){
        const x = Math.random()*W, y = Math.random()*H;
        const ang = rand(-Math.PI,Math.PI), sp=state.params.speed;
        state.flies.push({ x, y, vx: Math.cos(ang)*sp, vy: Math.sin(ang)*sp, info:[0,0,0] });
      }
    }

    function addObject(x,y,emoji){
      const type = state.emojiType.get(emoji)||'attractor';
      state.objs.push({x,y,emoji,type});
    }

    function removeNearestObject(x,y){
      if(!state.objs.length) return;
      let best=-1, bd=1e9;
      for(let i=0;i<state.objs.length;i++){
        const o=state.objs[i]; const d=dist2(x,y,o.x,o.y);
        if(d<bd){ bd=d; best=i; }
      }
      if(best>=0) state.objs.splice(best,1);
    }

    // Spatial hash for comm links
    function buildGrid(cell=80){
      const cols=Math.ceil(W/cell), rows=Math.ceil(H/cell);
      const g=Array.from({length:cols*rows},()=>[]);
      const idx=(x,y)=> clamp(Math.floor(x/cell),0,cols-1)+cols*clamp(Math.floor(y/cell),0,rows-1);
      for(let i=0;i<state.flies.length;i++){ const f=state.flies[i]; g[idx(f.x,f.y)].push(i); }
      state.grid={g,cell,cols,rows,idx};
    }

    function neighbors(i){
      const {g,cell,cols,rows,idx} = state.grid; const f=state.flies[i];
      const cx=clamp(Math.floor(f.x/cell),0,cols-1), cy=clamp(Math.floor(f.y/cell),0,rows-1);
      const res=[];
      for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++){
        const X=cx+dx, Y=cy+dy; if(X<0||Y<0||X>=cols||Y>=rows) continue;
        res.push(...g[X+cols*Y]);
      }
      return res;
    }

    function parallelTransport(info, vx, vy, dt, speed){
      const v = Math.hypot(vx,vy); if (v<1e-3) return;
      const a = Math.atan2(vy,vx);
      const s = Math.min(1, v/Math.max(1,speed));
      const theta = 0.7 * s * dt; // mixing rate
      // skew-symmetric generator coefficients (velocity-dependent)
      const a1 = 0.9*Math.cos(a), a2=0.9*Math.sin(a), a3=0.6*Math.cos(2*a);
      const r=info[0], g=info[1], b=info[2];
      // d(info) = theta * G * info
      const dr = theta * ( -a1*g + a2*b);
      const dg = theta * (  a1*r - a3*b);
      const db = theta * ( -a2*r + a3*g);
      info[0]=clamp(r+dr,-1,1); info[1]=clamp(g+dg,-1,1); info[2]=clamp(b+db,-1,1);
    }

    function step(dt){
      const {kAttr,kRepel,commR,infoRate,speed,forget,beta,social} = state.params;
      const commR2 = commR*commR;
      // Movement influenced by objects + forgetting first pass
      const N = state.flies.length; const ax = new Float32Array(N), ay = new Float32Array(N);
      for(let i=0;i<N;i++){
        const f = state.flies[i];
        // forget
        f.info[0] = clamp(f.info[0] - forget*f.info[0]*dt, -1, 1);
        f.info[1] = clamp(f.info[1] - forget*f.info[1]*dt, -1, 1);
        f.info[2] = clamp(f.info[2] - forget*f.info[2]*dt, -1, 1);
        for(const o of state.objs){
          const dx=o.x-f.x, dy=o.y-f.y; const r2=dx*dx+dy*dy+25; const r=Math.sqrt(r2);
          const idx = emojiColorIndex.get(o.emoji) ?? 0;
          const reactSign = (o.type==='attractor')? 1 : -1;
          const sensScale = 1 + beta * (f.info[idx]||0) * reactSign; // never flips sign
          const str = sensScale * (o.type==='attractor'? kAttr : -kRepel) / r2;
          ax[i] += str * dx / r; ay[i] += str * dy / r;
          // Sensing update
          if (r<60){ const sgn = (o.type==='attractor')? 1 : -1; f.info[idx] = clamp((f.info[idx]||0) + sgn * 1.8*dt, -1, 1); }
        }
      }
      // Communication (information passing) + social alignment on proximity graph
      buildGrid();
      const maxLinks=120; let drawn=0;
      for(let i=0;i<N;i++){
        const f = state.flies[i]; const vfi = Math.hypot(f.vx,f.vy)||1e-6; const ufi=[f.vx/vfi, f.vy/vfi];
        const neigh = neighbors(i);
        for(const j of neigh){ if(j<=i) continue; const g=state.flies[j];
          const d2 = dist2(f.x,f.y,g.x,g.y); if(d2>commR2) continue; const d=Math.sqrt(d2);
          const phi = 1 - d/commR; if (phi<=0) continue;
          const vrel = Math.hypot(f.vx-g.vx, f.vy-g.vy);
          const psi = 1/(1+vrel/40);
          const k = infoRate * phi * psi;
          // info exchange per component
          const dr = ((g.info[0]||0)-(f.info[0]||0)) * k * dt;
          const dg = ((g.info[1]||0)-(f.info[1]||0)) * k * dt;
          const db = ((g.info[2]||0)-(f.info[2]||0)) * k * dt;
          f.info[0]=clamp((f.info[0]||0)+dr,-1,1); g.info[0]=clamp((g.info[0]||0)-dr,-1,1);
          f.info[1]=clamp((f.info[1]||0)+dg,-1,1); g.info[1]=clamp((g.info[1]||0)-dg,-1,1);
          f.info[2]=clamp((f.info[2]||0)+db,-1,1); g.info[2]=clamp((g.info[2]||0)-db,-1,1);
          // social alignment: pull toward informed neighbor heading
          const infG = Math.max(Math.abs(g.info[0]||0), Math.abs(g.info[1]||0), Math.abs(g.info[2]||0));
          const infF = Math.max(Math.abs(f.info[0]||0), Math.abs(f.info[1]||0), Math.abs(f.info[2]||0));
          const w = social * phi * psi * 0.5;
          const vgj = Math.hypot(g.vx,g.vy)||1e-6; const ugj=[g.vx/vgj, g.vy/vgj];
          ax[i] += (ugj[0]-ufi[0]) * w * infG; ay[i] += (ugj[1]-ufi[1]) * w * infG;
          ax[j] += (ufi[0]-ugj[0]) * w * infF; ay[j] += (ufi[1]-ugj[1]) * w * infF;
          // draw info link colored by difference magnitude
          if (drawn<maxLinks){
            const mr = Math.abs(f.info[0]-g.info[0]);
            const mg = Math.abs(f.info[1]-g.info[1]);
            const mb = Math.abs(f.info[2]-g.info[2]);
            const alpha = 0.05 + 0.2*Math.max(mr,mg,mb);
            ctx.save(); ctx.globalAlpha = alpha;
            ctx.strokeStyle = `rgb(${Math.floor(200*mr)}, ${Math.floor(200*mg)}, ${Math.floor(200*mb)})`;
            ctx.beginPath(); ctx.moveTo(f.x,f.y); ctx.lineTo(g.x,g.y); ctx.stroke(); ctx.restore();
            drawn++;
          }
        }
      }
      // integrate
      for(let i=0;i<N;i++){
        const f=state.flies[i];
        f.vx = clamp(f.vx + ax[i]*dt, -160, 160);
        f.vy = clamp(f.vy + ay[i]*dt, -160, 160);
        parallelTransport(f.info, f.vx, f.vy, dt, speed);
        const v=Math.hypot(f.vx,f.vy)||1; const vmax=speed;
        if(v>vmax){ f.vx=f.vx/v*vmax; f.vy=f.vy/v*vmax; }
        f.x += f.vx*dt; f.y += f.vy*dt;
        if (f.x<4){ f.x=4; f.vx=Math.abs(f.vx); }
        if (f.x>W-4){ f.x=W-4; f.vx=-Math.abs(f.vx); }
        if (f.y<4){ f.y=4; f.vy=Math.abs(f.vy); }
        if (f.y>H-4){ f.y=H-4; f.vy=-Math.abs(f.vy); }
      }
    }

    function draw(){
      ctx.clearRect(0,0,W,H);
      // objects
      for(const o of state.objs){
        ctx.save(); ctx.font = '20px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(o.emoji, o.x, o.y);
        // halo
        ctx.globalAlpha = 0.1; ctx.beginPath(); ctx.arc(o.x,o.y, (o.type==='attractor'? 56:44), 0, Math.PI*2); ctx.fillStyle = (o.type==='attractor'? 'rgba(26,137,23,0.15)':'rgba(220,60,60,0.15)'); ctx.fill();
        ctx.restore();
      }
      // flies with info dots (RGB)
      for(const f of state.flies){
        // body
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.beginPath(); ctx.arc(f.x, f.y, 3.8, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.lineWidth = 0.6; ctx.stroke();
        // info dots around
        const R=5.6;
        const angs=[-Math.PI/2, -Math.PI/2 + 2*Math.PI/3, -Math.PI/2 + 4*Math.PI/3];
        const cols=[[230,40,30],[30,150,60],[40,90,220]]; // R,G,B
        for(let k=0;k<3;k++){
          const a=angs[k]; const x=f.x+R*Math.cos(a), y=f.y+R*Math.sin(a);
          const val = Math.abs(f.info[k]||0);
          const s=1.2+2.2*val;
          const c=cols[k]; ctx.fillStyle=`rgba(${c[0]},${c[1]},${c[2]},${0.25+0.6*val})`;
          // negative value -> dark ring to denote avoidance coding
          if ((f.info[k]||0) < 0){ ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.lineWidth=0.8; } else { ctx.strokeStyle='rgba(255,255,255,0.5)'; ctx.lineWidth=0.5; }
          ctx.beginPath(); ctx.arc(x,y, s, 0, Math.PI*2); ctx.fill();
          ctx.stroke();
        }
      }
    }

    // HUD
    function hud(){
      const el=document.getElementById('hud');
      // mean info vector
      let mr=0,mg=0,mb=0; for(const f of state.flies){ mr+=f.info[0]; mg+=f.info[1]; mb+=f.info[2]; }
      const n=state.flies.length||1; mr/=n; mg/=n; mb/=n;
      const concept = state.tool.emoji;
      el.innerHTML = `flies=${state.flies.length} • objs=${state.objs.length} • mean q=[${mr.toFixed(2)}, ${mg.toFixed(2)}, ${mb.toFixed(2)}]`+
                     `<div class="legend">Click to ${state.tool.mode==='add'?'place':'remove'} ${concept}. Shift-click always removes.</div>`;
    }

    // Interaction
    function pickTool(btn){
      document.querySelectorAll('.tool-btn[data-emoji]').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      state.tool.emoji = btn.getAttribute('data-emoji');
    }
    document.querySelectorAll('.tool-btn[data-emoji]').forEach(btn=>{
      btn.addEventListener('click', ()=> pickTool(btn));
    });
    pickTool(document.querySelector('.tool-btn[data-emoji="🍎"]'));
    const modeAdd=document.getElementById('modeAdd');
    const modeRemove=document.getElementById('modeRemove');
    function setMode(m){ state.tool.mode=m; modeAdd.classList.toggle('active', m==='add'); modeRemove.classList.toggle('active', m==='remove'); }
    modeAdd.addEventListener('click', ()=>setMode('add'));
    modeRemove.addEventListener('click', ()=>setMode('remove'));
    setMode('add');

    canvas.addEventListener('click', (e)=>{
      const r=canvas.getBoundingClientRect(); const x=(e.clientX-r.left), y=(e.clientY-r.top);
      if (e.shiftKey || state.tool.mode==='remove') removeNearestObject(x,y);
      else addObject(x,y,state.tool.emoji);
    });

    // Controls
    function bindRange(id, prop, fmt=(v)=>v){
      const el=document.getElementById(id); const lab=document.getElementById(id+'V');
      function upd(){ state.params[prop] = (id==='info'? parseFloat(el.value) : +el.value); lab.textContent = fmt(state.params[prop]); }
      el.addEventListener('input', ()=>{ upd(); if(prop==='N'){ initFlies(state.params.N); } });
      upd();
    }
    bindRange('flies','N');
    bindRange('attr','kAttr');
    bindRange('repel','kRepel');
    bindRange('comm','commR');
    bindRange('info','infoRate', v=>v.toFixed(2));
    bindRange('forget','forget', v=>v.toFixed(2));
    bindRange('beta','beta', v=>(+v).toFixed(2));
    bindRange('social','social');

    document.getElementById('togglePause').addEventListener('click', ()=>{ state.paused=!state.paused; document.getElementById('togglePause').textContent = state.paused?'Resume':'Pause'; });
    document.getElementById('clear').addEventListener('click', ()=>{ state.objs.length=0; state.flies.forEach(f=>{ f.info[0]=0; f.info[1]=0; f.info[2]=0; }); });
    // math panel toggle
    const mathPanel=document.getElementById('mathPanel');
    function toggleMath(){ mathPanel.classList.toggle('collapsed'); }
    document.getElementById('mathToggle').addEventListener('click', toggleMath);
    document.getElementById('toggleMath').addEventListener('click', toggleMath);
    // controls panel toggle
    const controlsPanel=document.getElementById('controlsPanel');
    document.getElementById('controlsToggle').addEventListener('click', ()=> controlsPanel.classList.toggle('collapsed'));
    document.getElementById('controlsHeader').addEventListener('click', ()=> controlsPanel.classList.toggle('collapsed'));

    // Loop
    let last=performance.now();
    function loop(now){
      const dt = Math.min(50, now-last)/1000; last=now;
      if(!state.paused){ step(dt); }
      draw(); hud(); requestAnimationFrame(loop);
    }

    // Boot
    function start(){ resize(); initFlies(state.params.N); requestAnimationFrame(loop); }
    window.addEventListener('resize', ()=>{ resize(); });
    start();
  })();
  </script>
</body>
</html>
