<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Information Flies ‚Äî Emoji Attractors & Repellents</title>
  <meta name="description" content="Place emoji concepts as attractors or repellents; watch flies move and pass information with finite speed." />
  <link rel="stylesheet" href="../style.css" />
  <style>
    html, body { height: 100%; }
    body { margin: 0; background: #fff; }
    .sim-root { position: fixed; inset: 0; display: grid; grid-template-rows: 1fr; }
    .toolbar { display: none; }
    .tool-group { display: flex; align-items: center; gap: 6px; }
    .tool-label { font-size: 14px; color: var(--muted); }
    .tool-btn { padding: 6px 10px; border: 1px solid var(--border); background: #fff; border-radius: 8px; cursor: pointer; font-size: 18px; line-height: 1; position: relative; }
    .tool-btn.active { outline: 2px solid var(--accent); }
    .tool { display: inline-flex; align-items: center; gap: 6px; }
    .tool input[type=range] { width: 120px; }
    .tool small { color: var(--muted); }
    #canvas { width: 100%; height: 100%; display: block; background: #ffffff; cursor: crosshair; }
    .hud { position: fixed; left: 12px; bottom: 12px; background: rgba(255,255,255,0.95); border: 1px solid var(--border); padding: 10px 12px; border-radius: 10px; font-size: 12px; color: var(--text); }
    .legend { color: var(--muted); font-size: 12px; }
    /* Emoji button color cues (channel + valence) */
    /* Flag buttons as colored blocks */
    .tool-btn[data-flag] { font-size: 12px; font-weight: 600; color:#fff; }
    .tool-btn[data-flag="red"] { background:#e44242; border-color:#d43a3a; }
    .tool-btn[data-flag="blue"] { background:#3b82f6; border-color:#2563eb; }
    .tool-btn[data-flag="white"] { background:#f3f4f6; border-color:#e5e7eb; color:#333; }
    /* Collapsible math panel */
    .panel.math { position: fixed; right: 12px; top: 12px; width: 380px; max-width: 92vw; z-index: 20; }
    .panel.collapsed { height: 48px; overflow: hidden; }
    .panel.collapsed .panel-content { display: none; }
    /* Controls panel */
    .panel.controls { position: fixed; left: 12px; top: 12px; width: 480px; max-width: 96vw; z-index: 20; }
    .controls .grid { display: grid; grid-template-columns: 1fr; gap: 10px; }
    .controls .row { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .controls .row small { color: var(--muted); width: 80px; flex:0 0 auto; }
    .controls input[type=range] { width: 240px; flex: 1 1 auto; }
    .panel-content { padding: 12px 16px 16px 16px; max-height: 70vh; overflow: auto; }
    @media (max-width: 600px){
      .panel.controls { width: 96vw; left: 2vw; }
      .controls input[type=range]{ width: 55vw; }
    }
    .tabs { display:flex; gap:8px; margin: 8px 0; }
    .tab-btn { padding:6px 10px; border:1px solid var(--border); background:#fff; border-radius:8px; cursor:pointer; font-size:12px; }
    .tab-btn.active { outline:2px solid var(--accent); }
    .tab-section { display:none; }
    .tab-section.active { display:block; }
  </style>
  <script>
    window.MathJax = {
      tex: { inlineMath: [['$', '$'], ['\\(', '\\)']], displayMath: [['$$', '$$'], ['\\[', '\\]']] },
      options: { skipHtmlTags: ['script','noscript','style','textarea','pre'] }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
  <div class="sim-root">
    <canvas id="canvas"></canvas>
  </div>
  <div class="panel controls" id="controlsPanel">
    <div class="panel-header" id="controlsHeader">
      <span class="panel-title">Controls</span>
      <button class="panel-toggle" id="controlsToggle">‚ñº</button>
    </div>
    <div class="panel-content" id="controlsContent">
      <div class="tabs">
        <button class="tab-btn active" id="tabTools">Tools</button>
        <button class="tab-btn" id="tabSettings">Settings</button>
      </div>
      <div class="tab-section active" id="toolsSection">
        <div class="grid">
          <div>
          <div class="tool-label" style="margin-bottom:6px;">Flags</div>
          <div class="tool-group" style="flex-wrap:wrap; gap:6px;">
            <button class="tool-btn" data-flag="red" title="Red Flag">üö© Red</button>
            <button class="tool-btn" data-flag="blue" title="Blue Flag">üö© Blue</button>
            <button class="tool-btn" data-flag="white" title="White Flag">üè≥Ô∏è White</button>
          </div>
            <div class="tool-group" style="margin-top:8px;">
              <span class="tool-label">Mode</span>
              <button class="tool-btn" id="modeAdd">Add</button>
              <button class="tool-btn" id="modeRemove">Remove</button>
            </div>
          </div>
          <div>
            <div class="tool-group" style="margin-top:0; gap:8px;">
              <button class="btn-secondary tool-btn" id="toggleMath">Math</button>
              <button class="btn-secondary tool-btn" id="togglePause">Pause</button>
              <button class="btn-secondary tool-btn" id="clear">Clear</button>
              <a href="../index.html" class="btn-secondary tool-btn">Home</a>
            </div>
          </div>
        </div>
      </div>
      <div class="tab-section" id="settingsSection">
        <div class="grid">
          <div>
            <div class="row"><small>Flies</small><input id="flies" type="range" min="60" max="500" step="10" value="220" /><small id="fliesV">220</small></div>
            <div class="row"><small>Flag Force</small><input id="attr" type="range" min="0" max="300" step="1" value="140" /><small id="attrV">140</small></div>
            <div class="row"><small>Comm</small><input id="comm" type="range" min="20" max="260" step="1" value="110" /><small id="commV">110</small></div>
            <div class="row"><small>Cohesion</small><input id="cohesion" type="range" min="0" max="200" step="2" value="36" /><small id="cohesionV">36</small></div>
          </div>
          <div>
            <div class="row"><small>Influence</small><input id="info" type="range" min="0" max="4" step="0.05" value="1.2" /><small id="infoV">1.20</small></div>
            <div class="row"><small>Forget</small><input id="forget" type="range" min="0" max="2" step="0.02" value="0.18" /><small id="forgetV">0.18</small></div>
            <div class="row"><small>Social</small><input id="social" type="range" min="0" max="200" step="2" value="72" /><small id="socialV">72</small></div>
            <div class="row"><small>Separation</small><input id="separation" type="range" min="0" max="300" step="2" value="120" /><small id="separationV">120</small></div>
            <div class="row"><small>SepDist</small><input id="sepDist" type="range" min="5" max="80" step="1" value="28" /><small id="sepDistV">28</small></div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div class="hud" id="hud"></div>
  <div class="panel math collapsed" id="mathPanel">
    <div class="panel-header" id="mathHeader">
      <span class="panel-title">Flag Influence ‚Äî Model</span>
      <button class="panel-toggle" id="mathToggle">‚ñº</button>
    </div>
    <div class="panel-content">
      <div class="article-content" style="font-size:14px;">
        <p>We place control flags $k$ (red/blue/white) in the plane. Each fly $i$ carries an allegiance label $L_i$ (the flag it follows)
        and a scalar influence strength $s_i \in [0,1]$ (neutral if $s_i \approx 0$). Physics couples motion, sensing, and local communication.</p>
        <p>Motion (with damping):</p>
        $$\dot x_i = v_i,\quad \dot v_i = \sum_k F_k(x_i,L_i,s_i) - \gamma v_i$$
        where the flag force near flag $k$ is attractive and scales with allegiance:
        $$F_k \propto \frac{\alpha(L_i,k,s_i)}{\|x_i-x_k\|^2}\, \frac{x_k - x_i}{\|x_k-x_i\|},\qquad
          \alpha = \begin{cases}
          \alpha_0 & L_i<0 \text{ (neutral: stronger bias)}\\
          \alpha_1(0.8+0.4s_i) & L_i=k \text{ (follow own flag)}\\
          \alpha_2 & L_i\neq k \text{ (weak cross-bias)}
          \end{cases} $$
        <p>Sensing and forgetting:</p>
        $$\dot s_i = \eta\,\sigma(\|x_i-x_{L_i}\|) - \lambda s_i,$$
        where $\sigma$ increases near a flag; neutral flies adopt the nearest flag on contact.</p>
        <p>Local communication (label propagation):</p>
        $$\dot s_i \mathrel{+}= \sum_j w_{ij}(s_j - s_i),\qquad
          L_i \leftarrow L_j \text{ if } s_j > s_i,$$
        with $w_{ij}=\phi(\|x_i-x_j\|)\,\psi(\|v_i-v_j\|)$ decaying with distance and relative speed.
        <p>Social terms (cohesion/separation/alignment) are awareness-weighted so informed flies coordinate flocks while neutrals seek flags.</p>
      </div>
    </div>
  </div>

  <script>
  (function(){
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let W=0, H=0, DPR=Math.max(1, Math.min(2, window.devicePixelRatio||1));
    const rand = (a,b)=>Math.random()*(b-a)+a;
    const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
    const dist2=(ax,ay,bx,by)=>{const dx=ax-bx,dy=ay-by;return dx*dx+dy*dy;};

    const state = {
      flies: [], // {x,y,vx,vy,info:[r,g,b], allegiance:-1, s:0}
      objs: [],  // {x,y,emoji,type:'flag', color?:'red'|'blue'|'white', qty?, maxQty?}
      grid: null, // spatial hash
      params: { N:220, kFlag:140, commR:110, influence:1.2, speed:42, forget:0.18, social:72, cohesion:36, separation:120, sepDist:28 },
      paused:false,
      tool: { flag:'red', mode:'add' },
    };

    // no legacy emoji mapping

    function resize(){
      W = canvas.clientWidth = window.innerWidth;
      H = canvas.clientHeight = window.innerHeight;
      canvas.width = Math.floor(W*DPR); canvas.height = Math.floor(H*DPR);
      canvas.style.width = W+'px'; canvas.style.height = H+'px';
      ctx.setTransform(DPR,0,0,DPR,0,0);
    }

    function initFlies(N){
      state.flies.length = 0;
      for(let i=0;i<N;i++){
        const x = Math.random()*W, y = Math.random()*H;
        const ang = rand(-Math.PI,Math.PI), sp=state.params.speed;
        state.flies.push({ x, y, vx: Math.cos(ang)*sp, vy: Math.sin(ang)*sp, info:[0,0,0], allegiance:-1, s:0 });
      }
    }

    function addObject(x,y,flagColor){
      // place a control flag that biases local motion
      const color = flagColor || 'red';
      const emoji = (color==='white')? 'üè≥Ô∏è' : 'üö©';
      state.objs.push({x,y,emoji,type:'flag', color});
    }

    function removeNearestObject(x,y){
      if(!state.objs.length) return;
      let best=-1, bd=1e9;
      for(let i=0;i<state.objs.length;i++){
        const o=state.objs[i]; const d=dist2(x,y,o.x,o.y);
        if(d<bd){ bd=d; best=i; }
      }
      if(best>=0){
        state.objs.splice(best,1);
        for(const f of state.flies){
          if (f.allegiance===best) { f.allegiance=-1; f.s=0; }
          else if (f.allegiance>best) { f.allegiance--; }
        }
      }
    }

    // Spatial hash for comm links
    function buildGrid(cell=80){
      const cols=Math.ceil(W/cell), rows=Math.ceil(H/cell);
      const g=Array.from({length:cols*rows},()=>[]);
      const idx=(x,y)=> clamp(Math.floor(x/cell),0,cols-1)+cols*clamp(Math.floor(y/cell),0,rows-1);
      for(let i=0;i<state.flies.length;i++){ const f=state.flies[i]; g[idx(f.x,f.y)].push(i); }
      state.grid={g,cell,cols,rows,idx};
    }

    function neighbors(i){
      const {g,cell,cols,rows,idx} = state.grid; const f=state.flies[i];
      const cx=clamp(Math.floor(f.x/cell),0,cols-1), cy=clamp(Math.floor(f.y/cell),0,rows-1);
      const res=[];
      for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++){
        const X=cx+dx, Y=cy+dy; if(X<0||Y<0||X>=cols||Y>=rows) continue;
        res.push(...g[X+cols*Y]);
      }
      return res;
    }

    function parallelTransport(info, vx, vy, dt, speed){
      const v = Math.hypot(vx,vy); if (v<1e-3) return;
      const a = Math.atan2(vy,vx);
      const s = Math.min(1, v/Math.max(1,speed));
      const theta = 0.7 * s * dt; // mixing rate
      // skew-symmetric generator coefficients (velocity-dependent)
      const a1 = 0.9*Math.cos(a), a2=0.9*Math.sin(a), a3=0.6*Math.cos(2*a);
      const r=info[0], g=info[1], b=info[2];
      // d(info) = theta * G * info
      const dr = theta * ( -a1*g + a2*b);
      const dg = theta * (  a1*r - a3*b);
      const db = theta * ( -a2*r + a3*g);
      info[0]=clamp(r+dr,-1,1); info[1]=clamp(g+dg,-1,1); info[2]=clamp(b+db,-1,1);
    }

    function step(dt){
      const {kFlag,commR,influence,speed,forget,social} = state.params;
      const commR2 = commR*commR;
      const N = state.flies.length; const ax = new Float32Array(N), ay = new Float32Array(N);
      const useFlags = true
      if (useFlags){
        // Flags: allegiance-based attraction and sensing
        for(let i=0;i<N;i++){
          const f = state.flies[i];
          f.s = clamp((f.s||0) - forget*(f.s||0)*dt, 0, 1);
          // nearest flag
          let kmin=-1, dmin=1e18, ox=0, oy=0, col='red';
          for(let k=0;k<state.objs.length;k++){
            const o=state.objs[k]; if(o.type!=='flag') continue;
            const dx=o.x-f.x, dy=o.y-f.y; const d2=dx*dx+dy*dy; if(d2<dmin){ dmin=d2; kmin=k; ox=o.x; oy=o.y; col=o.color||'red'; }
          }
          if (kmin>=0){
            const dx=ox-f.x, dy=oy-f.y; const r2=dmin+25; const r=Math.sqrt(r2);
            const towards = (f.allegiance==null || f.allegiance<0)? 1.3 : ((f.allegiance===kmin)? (0.8+0.4*(f.s||0)) : 0.15);
            const str = (kFlag * towards) / r2;
            ax[i] += str * dx / r; ay[i] += str * dy / r;
            if (r < consumeR){ f.s = clamp((f.s||0) + 1.2*dt, 0, 1); if (f.allegiance==null || f.allegiance<0) f.allegiance = kmin; }
            const cv = (col==='red')? [1,0,0] : (col==='blue')? [0,0,1] : [0.7,0.7,0.7];
            f.info[0]=cv[0]*(f.s||0); f.info[1]=cv[1]*(f.s||0); f.info[2]=cv[2]*(f.s||0);
          } else {
            f.info[0]=f.info[1]=f.info[2]=0;
          }
        }
      
      }
 }
      // communication + social alignment
      buildGrid();
      const maxLinks=120; let drawn=0;
      for(let i=0;i<N;i++){
        const f = state.flies[i]; const vfi = Math.hypot(f.vx,f.vy)||1e-6; const ufi=[f.vx/vfi, f.vy/vfi];
        const neigh = neighbors(i);
        for(const j of neigh){ if(j<=i) continue; const g=state.flies[j];
          const d2 = dist2(f.x,f.y,g.x,g.y); if(d2>commR2) continue; const d=Math.sqrt(d2);
          const phi = 1 - d/commR; if (phi<=0) continue;
          const vrel = Math.hypot(f.vx-g.vx, f.vy-g.vy);
          const psi = 1/(1+vrel/40);
          const k = influence * phi * psi;
          if (useFlags){
            const ds = ((g.s||0) - (f.s||0)) * k * dt;
            f.s = clamp((f.s||0) + ds, 0, 1);
            g.s = clamp((g.s||0) - ds, 0, 1);
            if ((g.s||0) > (f.s||0) && g.allegiance!=null && g.allegiance>=0) f.allegiance = g.allegiance;
            if ((f.s||0) > (g.s||0) && f.allegiance!=null && f.allegiance>=0) g.allegiance = f.allegiance;
            const colf = (f.allegiance!=null && f.allegiance>=0)? (state.objs[f.allegiance].color||'red') : 'none';
            const cvf = (colf==='red')?[1,0,0]:(colf==='blue')?[0,0,1]:(colf==='white')?[0.7,0.7,0.7]:[0,0,0];
            f.info[0]=cvf[0]*(f.s||0); f.info[1]=cvf[1]*(f.s||0); f.info[2]=cvf[2]*(f.s||0);
            const colg = (g.allegiance!=null && g.allegiance>=0)? (state.objs[g.allegiance].color||'red') : 'none';
            const cvg = (colg==='red')?[1,0,0]:(colg==='blue')?[0,0,1]:(colg==='white')?[0.7,0.7,0.7]:[0,0,0];
            g.info[0]=cvg[0]*(g.s||0); g.info[1]=cvg[1]*(g.s||0); g.info[2]=cvg[2]*(g.s||0);
          } else {
            const dr = ((g.info[0]||0)-(f.info[0]||0)) * k * dt;
            const dg = ((g.info[1]||0)-(f.info[1]||0)) * k * dt;
            const db = ((g.info[2]||0)-(f.info[2]||0)) * k * dt;
            f.info[0]=clamp((f.info[0]||0)+dr,-1,1); g.info[0]=clamp((g.info[0]||0)-dr,-1,1);
            f.info[1]=clamp((f.info[1]||0)+dg,-1,1); g.info[1]=clamp((g.info[1]||0)-dg,-1,1);
            f.info[2]=clamp((f.info[2]||0)+db,-1,1); g.info[2]=clamp((g.info[2]||0)-db,-1,1);
          }
          const infG = Math.max(Math.abs(g.info[0]||0), Math.abs(g.info[1]||0), Math.abs(g.info[2]||0));
          const infF = Math.max(Math.abs(f.info[0]||0), Math.abs(f.info[1]||0), Math.abs(f.info[2]||0));
          const w = social * phi * psi * 0.5;
          const vgj = Math.hypot(g.vx,g.vy)||1e-6; const ugj=[g.vx/vgj, g.vy/vgj];
          ax[i] += (ugj[0]-ufi[0]) * w * infG; ay[i] += (ugj[1]-ufi[1]) * w * infG;
          ax[j] += (ufi[0]-ugj[0]) * w * infF; ay[j] += (ufi[1]-ugj[1]) * w * infF;
          if (drawn<maxLinks){
            const mr = Math.abs(f.info[0]-g.info[0]);
            const mg = Math.abs(f.info[1]-g.info[1]);
            const mb = Math.abs(f.info[2]-g.info[2]);
            const alpha = 0.05 + 0.2*Math.max(mr,mg,mb);
            ctx.save(); ctx.globalAlpha = alpha;
            ctx.strokeStyle = `rgb(${Math.floor(200*mr)}, ${Math.floor(200*mg)}, ${Math.floor(200*mb)})`;
            ctx.beginPath(); ctx.moveTo(f.x,f.y); ctx.lineTo(g.x,g.y); ctx.stroke(); ctx.restore();
            drawn++;
          }
        }
      }
      // boids-style cohesion and separation (awareness weighted)
      for(let i=0;i<N;i++){
        const f = state.flies[i];
        const neigh = neighbors(i);
        let cx=0, cy=0, wsum=0; // cohesion
        let sx=0, sy=0;        // separation
        for(const j of neigh){ if(j===i) continue; const g=state.flies[j];
          const dx=g.x-f.x, dy=g.y-f.y; const d2=dx*dx+dy*dy; const d=Math.sqrt(d2)+1e-6;
          const phi = Math.max(0, 1 - d/state.params.commR);
          const inf = Math.max(Math.abs(g.info[0]||0), Math.abs(g.info[1]||0), Math.abs(g.info[2]||0));
          const w = phi * (0.5+0.5*inf);
          cx += g.x * w; cy += g.y * w; wsum += w;
          const sep = Math.max(0, state.params.sepDist - d);
          if (sep>0){ sx += -(dx/d) * (sep*sep/d); sy += -(dy/d) * (sep*sep/d); }
        }
        if (wsum>0){
          const tx = (cx/wsum) - f.x; const ty = (cy/wsum) - f.y;
          ax[i] += state.params.cohesion * tx * 0.0015;
          ay[i] += state.params.cohesion * ty * 0.0015;
        }
        ax[i] += state.params.separation * sx * 0.0025;
        ay[i] += state.params.separation * sy * 0.0025;
      }
      // integrate + capacity (keep top-K channels)
      for(let i=0;i<N;i++){
        const f=state.flies[i];
        f.vx = clamp(f.vx + ax[i]*dt, -160, 160);
        f.vy = clamp(f.vy + ay[i]*dt, -160, 160);
        parallelTransport(f.info, f.vx, f.vy, dt, speed);
        const K = Math.max(1, Math.min(3, state.params.memorySlots||2));
        const arr = [
          {i:0, a:Math.abs(f.info[0]||0)},
          {i:1, a:Math.abs(f.info[1]||0)},
          {i:2, a:Math.abs(f.info[2]||0)}
        ].sort((u,v)=>v.a-u.a);
        for(let idx=K; idx<3; idx++){
          const j = arr[idx].i; const sgn = Math.sign(f.info[j]||0);
          const dec = Math.min(Math.abs(f.info[j]||0), capDecay*dt);
          f.info[j] = (f.info[j]||0) - sgn*dec;
        }
        const v=Math.hypot(f.vx,f.vy)||1; const vmax=speed;
        if(v>vmax){ f.vx=f.vx/v*vmax; f.vy=f.vy/v*vmax; }
        f.x += f.vx*dt; f.y += f.vy*dt;
        if (f.x<4){ f.x=4; f.vx=Math.abs(f.vx); }
        if (f.x>W-4){ f.x=W-4; f.vx=-Math.abs(f.vx); }
        if (f.y<4){ f.y=4; f.vy=Math.abs(f.vy); }
        if (f.y>H-4){ f.y=H-4; f.vy=-Math.abs(f.vy); }
      }
      // flags have no depletion/removal other than manual removal
    }

    function draw(){
      ctx.clearRect(0,0,W,H);
      // objects
      for(const o of state.objs){
        ctx.save(); ctx.font = '20px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
        // no heatmap for flags
        // draw a simple flag (pole + colored banner)
        const col = (o.color==='red')? '#e44242' : (o.color==='blue')? '#3b82f6' : '#f3f4f6';
        const w=28, h=16, pole=10;
        ctx.globalAlpha=1; ctx.strokeStyle='#888'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(o.x-pole, o.y-h/2); ctx.lineTo(o.x-pole, o.y+h/2+6); ctx.stroke();
        ctx.fillStyle=col; ctx.strokeStyle='#222'; ctx.lineWidth=1;
        ctx.beginPath(); ctx.rect(o.x-pole+2, o.y-h/2, w, h); ctx.fill(); ctx.stroke();
        ctx.restore();
      }
      // flies with info dots (RGB) and direction hint
      for(const f of state.flies){
        // body
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.beginPath(); ctx.arc(f.x, f.y, 3.8, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.lineWidth = 0.6; ctx.stroke();
        // direction hint
        const vmag = Math.hypot(f.vx,f.vy);
        if (vmag>1e-2){
          const ux=f.vx/vmag, uy=f.vy/vmag; const L=7;
          const a0=Math.abs(f.info[0]||0), a1=Math.abs(f.info[1]||0), a2=Math.abs(f.info[2]||0);
          let kdom=0, ad=a0; if(a1>ad){kdom=1; ad=a1;} if(a2>ad){kdom=2; ad=a2;}
          const cols=[[230,40,30],[30,150,60],[40,90,220]]; const c=cols[kdom];
          ctx.strokeStyle = `rgba(${c[0]},${c[1]},${c[2]},${0.25+0.45*ad})`;
          ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(f.x, f.y); ctx.lineTo(f.x+ux*L, f.y+uy*L); ctx.stroke();
        }
        // info dots around
        const R=5.6;
        const angs=[-Math.PI/2, -Math.PI/2 + 2*Math.PI/3, -Math.PI/2 + 4*Math.PI/3];
        const cols=[[230,40,30],[30,150,60],[40,90,220]]; // R,G,B
        for(let k=0;k<3;k++){
          const a=angs[k]; const x=f.x+R*Math.cos(a), y=f.y+R*Math.sin(a);
          const val = Math.abs(f.info[k]||0);
          const s=1.2+2.2*val;
          const c=cols[k]; ctx.fillStyle=`rgba(${c[0]},${c[1]},${c[2]},${0.25+0.6*val})`;
          if ((f.info[k]||0) < 0){ ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.lineWidth=0.8; } else { ctx.strokeStyle='rgba(255,255,255,0.5)'; ctx.lineWidth=0.5; }
          ctx.beginPath(); ctx.arc(x,y, s, 0, Math.PI*2); ctx.fill();
          ctx.stroke();
        }
      }
    }

    // HUD
    function hud(){
      const el=document.getElementById('hud');
      // mean info vector
      let mr=0,mg=0,mb=0; for(const f of state.flies){ mr+=f.info[0]; mg+=f.info[1]; mb+=f.info[2]; }
      const n=state.flies.length||1; mr/=n; mg/=n; mb/=n;
      const concept = state.tool.emoji;
      el.innerHTML = `flies=${state.flies.length} ‚Ä¢ objs=${state.objs.length} ‚Ä¢ mean q=[${mr.toFixed(2)}, ${mg.toFixed(2)}, ${mb.toFixed(2)}]`+
                     `<div class="legend">Click to ${state.tool.mode==='add'?'place':'remove'} ${concept}. Shift-click always removes.</div>`;
    }

    // Interaction
    function pickFlag(btn){
      document.querySelectorAll('.tool-btn[data-flag]').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      state.tool.flag = btn.getAttribute('data-flag');
    }
    document.querySelectorAll('.tool-btn[data-flag]').forEach(btn=>{
      btn.addEventListener('click', ()=> pickFlag(btn));
    });
    pickFlag(document.querySelector('.tool-btn[data-flag="red"]'));
    const modeAdd=document.getElementById('modeAdd');
    const modeRemove=document.getElementById('modeRemove');
    function setMode(m){ state.tool.mode=m; modeAdd.classList.toggle('active', m==='add'); modeRemove.classList.toggle('active', m==='remove'); }
    modeAdd.addEventListener('click', ()=>setMode('add'));
    modeRemove.addEventListener('click', ()=>setMode('remove'));
    setMode('add');

    canvas.addEventListener('click', (e)=>{
      const r=canvas.getBoundingClientRect(); const x=(e.clientX-r.left), y=(e.clientY-r.top);
      if (e.shiftKey || state.tool.mode==='remove') removeNearestObject(x,y);
      else addObject(x,y,state.tool.flag);
    });

    // Controls
    function bindRange(id, prop, fmt=(v)=>v){
      const el=document.getElementById(id); const lab=document.getElementById(id+'V');
      function upd(){ state.params[prop] = (id==='info'? parseFloat(el.value) : +el.value); lab.textContent = fmt(state.params[prop]); }
      el.addEventListener('input', ()=>{ upd(); if(prop==='N'){ initFlies(state.params.N); } });
      upd();
    }
    bindRange('flies','N');
    bindRange('attr','kFlag');
    bindRange('comm','commR');
    bindRange('info','influence', v=>v.toFixed(2));
    bindRange('forget','forget', v=>v.toFixed(2));
    bindRange('social','social');
    bindRange('cohesion','cohesion');
    bindRange('separation','separation');
    bindRange('sepDist','sepDist');

    document.getElementById('togglePause').addEventListener('click', ()=>{ state.paused=!state.paused; document.getElementById('togglePause').textContent = state.paused?'Resume':'Pause'; });
    document.getElementById('clear').addEventListener('click', ()=>{ state.objs.length=0; state.flies.forEach(f=>{ f.info[0]=0; f.info[1]=0; f.info[2]=0; }); });
    // math panel toggle
    const mathPanel=document.getElementById('mathPanel');
    function toggleMath(){ mathPanel.classList.toggle('collapsed'); }
    document.getElementById('mathToggle').addEventListener('click', toggleMath);
    document.getElementById('mathHeader').addEventListener('click', toggleMath);
    document.getElementById('toggleMath').addEventListener('click', toggleMath);
    // controls panel + tabs
    const controlsPanel=document.getElementById('controlsPanel');
    document.getElementById('controlsToggle').addEventListener('click', ()=> controlsPanel.classList.toggle('collapsed'));
    document.getElementById('controlsHeader').addEventListener('click', ()=> controlsPanel.classList.toggle('collapsed'));
    const tabTools=document.getElementById('tabTools');
    const tabSettings=document.getElementById('tabSettings');
    const toolsSection=document.getElementById('toolsSection');
    const settingsSection=document.getElementById('settingsSection');
    function setTab(which){
      const tools = which==='tools';
      tabTools.classList.toggle('active', tools);
      tabSettings.classList.toggle('active', !tools);
      toolsSection.classList.toggle('active', tools);
      settingsSection.classList.toggle('active', !tools);
    }
    tabTools.addEventListener('click', ()=> setTab('tools'));
    tabSettings.addEventListener('click', ()=> setTab('settings'));
    setTab('tools');

    // Persist settings
    function saveSettings(){
      try{
        const p=state.params; const data={ N:p.N,kFlag:p.kFlag,commR:p.commR,influence:p.influence,speed:p.speed,forget:p.forget,social:p.social,cohesion:p.cohesion,separation:p.separation,sepDist:p.sepDist };
        localStorage.setItem('infoflies.settings', JSON.stringify(data));
      }catch(e){}
    }
    function loadSettings(){
      try{
        const raw=localStorage.getItem('infoflies.settings'); if(!raw) return; const d=JSON.parse(raw);
        const set=(id,val)=>{ const el=document.getElementById(id); if(!el) return; el.value=String(val); el.dispatchEvent(new Event('input',{bubbles:true})); };
        for(const [id,key] of [['flies','N'],['attr','kFlag'],['comm','commR'],['info','influence'],['forget','forget'],['social','social'],['cohesion','cohesion'],['separation','separation'],['sepDist','sepDist']]){
          if(d[key]!==undefined) set(id,d[key]);
        }
      }catch(e){}
    }
    // attach save to sliders
    document.querySelectorAll('#settingsSection input[type=range]').forEach(el=> el.addEventListener('input', saveSettings));
    loadSettings();

    // Loop
    let last=performance.now();
    function loop(now){
      const dt = Math.min(50, now-last)/1000; last=now;
      if(!state.paused){ step(dt); }
      draw(); hud(); requestAnimationFrame(loop);
    }

    // Boot
    function start(){ resize(); initFlies(state.params.N); requestAnimationFrame(loop); }
    window.addEventListener('resize', ()=>{ resize(); });
    start();
  })();
  </script>
</body>
</html>
