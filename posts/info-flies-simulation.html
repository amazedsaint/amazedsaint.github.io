<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Game of Flies — Build Houses, Add Hazards</title>
  <meta name="description" content="Place houses and hazards. Flies explore, join teams, orbit flags, fight rivals, and sometimes switch sides." />
  <link rel="stylesheet" href="../style.css" />
  <style>
    html, body { height: 100%; }
    body { margin: 0; background: #fff; }
    .sim-root { position: fixed; inset: 0; display: grid; grid-template-rows: 1fr; }
    .toolbar { display: none; }
    .tool-group { display: flex; align-items: center; gap: 6px; }
    .tool-label { font-size: 14px; color: var(--muted); }
    .tool-btn { padding: 6px 10px; border: 1px solid var(--border); background: #fff; border-radius: 8px; cursor: pointer; font-size: 18px; line-height: 1; position: relative; }
    .tool-btn.active { outline: 2px solid var(--accent); }
    .tool { display: inline-flex; align-items: center; gap: 6px; }
    .tool input[type=range] { width: 120px; }
    .tool small { color: var(--muted); }
    #canvas { width: 100%; height: 100%; display: block; background: #ffffff; cursor: crosshair; }
    .hud { position: fixed; left: 12px; bottom: 12px; background: rgba(255,255,255,0.95); border: 1px solid var(--border); padding: 10px 12px; border-radius: 10px; font-size: 12px; color: var(--text); }
    .legend { color: var(--muted); font-size: 12px; }
    .sim-title { position: fixed; left: 50%; top: 10px; transform: translateX(-50%); z-index: 25; background: rgba(255,255,255,0.92); border:1px solid var(--border); padding: 6px 10px; border-radius: 999px; font-weight: 700; color: var(--text); box-shadow: 0 2px 8px rgba(0,0,0,0.06); }
    /* Emoji button color cues (channel + valence) */
    /* Flag buttons as colored blocks */
    /* House buttons */
    .tool-btn[data-house] { font-size: 12px; font-weight: 700; color:#fff; }
    .tool-btn[data-house="stark"] { background:#6b7280; border-color:#4b5563; }
    .tool-btn[data-house="lannister"] { background:#b91c1c; border-color:#991b1b; }
    .tool-btn[data-house="targaryen"] { background:#111827; border-color:#1f2937; }
    .tool-btn[data-house="tyrell"] { background:#065f46; border-color:#065f46; }
    .tool-btn[data-house="walkers"] { background:#3b82f6; border-color:#2563eb; }
    .tool-btn[data-house="wildfire"] { background:#10b981; border-color:#059669; }
    /* Collapsible math panel */
    .panel.math { position: fixed; right: 12px; top: 12px; width: 380px; max-width: 92vw; z-index: 20; }
    .panel.collapsed { height: 48px; overflow: hidden; }
    .panel.collapsed .panel-content { display: none; }
    /* Controls panel */
    .panel.controls { position: fixed; left: 12px; top: 12px; width: 480px; max-width: 96vw; z-index: 20; }
    .controls .grid { display: grid; grid-template-columns: 1fr; gap: 10px; }
    .controls .row { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .controls .row small { color: var(--muted); width: 80px; flex:0 0 auto; }
    .controls input[type=range] { width: 240px; flex: 1 1 auto; }
    .panel-content { padding: 12px 16px 16px 16px; max-height: 70vh; overflow: auto; }
    @media (max-width: 600px){
      .panel.controls { width: 96vw; left: 2vw; }
      .controls input[type=range]{ width: 55vw; }
    }
    .tabs { display:flex; gap:8px; margin: 8px 0; }
    .tab-btn { padding:6px 10px; border:1px solid var(--border); background:#fff; border-radius:8px; cursor:pointer; font-size:12px; }
    .tab-btn.active { outline:2px solid var(--accent); }
    .tab-section { display:none; }
    .tab-section.active { display:block; }
    /* Tooltip and legend */
    .flag-tip { position: fixed; pointer-events: none; background: rgba(0,0,0,0.8); color:#fff; font-size:12px; padding:6px 8px; border-radius:6px; border:1px solid rgba(255,255,255,0.2); z-index: 30; display:none; }
    .legend-mini { position: fixed; right: 12px; bottom: 12px; background: rgba(255,255,255,0.95); border:1px solid var(--border); padding:8px 10px; border-radius:8px; font-size:12px; color:var(--text); }
    .legend-row { display:flex; align-items:center; gap:8px; }
    .swatch { width:10px; height:10px; border-radius:2px; display:inline-block; }
    .swatch.red{ background:#e44242; }
    .swatch.blue{ background:#3b82f6; }
    .swatch.white{ background:#f3f4f6; border:1px solid #e5e7eb; }
  </style>
  <script>
    // Guard against duplicate custom element registrations from third‑party overlays
    (function(){
      try {
        if (window.customElements && typeof window.customElements.define === 'function') {
          const reg = window.customElements;
          const _define = reg.define.bind(reg);
          reg.define = function(name, ctor, options){
            if (reg.get && reg.get(name)) { return; }
            return _define(name, ctor, options);
          };
        }
      } catch (_) { /* no-op */ }
    })();
  </script>
  <script>
    window.MathJax = {
      tex: { inlineMath: [['$', '$'], ['\\(', '\\)']], displayMath: [['$$', '$$'], ['\\[', '\\]']] },
      options: { skipHtmlTags: ['script','noscript','style','textarea','pre'] }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
  <div class="sim-root">
    <canvas id="canvas"></canvas>
  </div>
  <div class="sim-title" id="simTitle">Game of Flies</div>
  <div class="panel controls" id="controlsPanel">
    <div class="panel-header" id="controlsHeader">
      <span class="panel-title">Controls</span>
      <button class="panel-toggle" id="controlsToggle">▼</button>
    </div>
    <div class="panel-content" id="controlsContent">
      <div class="tabs">
        <button class="tab-btn active" id="tabTools">Tools</button>
        <button class="tab-btn" id="tabSettings">Settings</button>
      </div>
      <div class="tab-section active" id="toolsSection">
        <div class="grid">
          <div>
          <div class="tool-label" style="margin-bottom:6px;">Houses (Attractors)</div>
          <div class="tool-group" style="flex-wrap:wrap; gap:6px;">
            <button class="tool-btn" data-house="stark" title="House Stark">Stark</button>
            <button class="tool-btn" data-house="lannister" title="House Lannister">Lannister</button>
            <button class="tool-btn" data-house="targaryen" title="House Targaryen">Targaryen</button>
            <button class="tool-btn" data-house="tyrell" title="House Tyrell">Tyrell</button>
          </div>
          <div class="tool-label" style="margin:10px 0 6px 0;">Hazards (Repellents)</div>
          <div class="tool-group" style="flex-wrap:wrap; gap:6px;">
            <button class="tool-btn" data-house="walkers" title="White Walkers">Walkers</button>
            <button class="tool-btn" data-house="wildfire" title="Wildfire">Wildfire</button>
          </div>
            <div class="tool-group" style="margin-top:8px;">
              <span class="tool-label">Mode</span>
              <button class="tool-btn" id="modeAdd">Add</button>
              <button class="tool-btn" id="modeRemove">Remove</button>
            </div>
          </div>
          <div>
            <div class="tool-group" style="margin-top:0; gap:8px;">
              <button class="btn-secondary tool-btn" id="toggleMath">Math</button>
              <button class="btn-secondary tool-btn" id="togglePause">Pause</button>
              <button class="btn-secondary tool-btn" id="resetSettings">Reset</button>
              <button class="btn-secondary tool-btn" id="clear">Clear</button>
              <a href="../index.html" class="btn-secondary tool-btn">Home</a>
            </div>
          </div>
        </div>
      </div>
      <div class="tab-section" id="settingsSection">
        <div class="grid">
          <div>
            <div class="row"><small>Flies</small><input id="flies" type="range" min="60" max="500" step="10" value="220" /><small id="fliesV">220</small></div>
            <div class="row"><small>Flag Force</small><input id="attr" type="range" min="0" max="300" step="1" value="140" /><small id="attrV">140</small></div>
            <div class="row"><small>Comm</small><input id="comm" type="range" min="20" max="260" step="1" value="110" /><small id="commV">110</small></div>
            <div class="row"><small>Cohesion</small><input id="cohesion" type="range" min="0" max="200" step="2" value="36" /><small id="cohesionV">36</small></div>
          </div>
          <div>
            <div class="row"><small>Influence</small><input id="info" type="range" min="0" max="4" step="0.05" value="1.2" /><small id="infoV">1.20</small></div>
            <div class="row"><small>Forget</small><input id="forget" type="range" min="0" max="2" step="0.02" value="0.18" /><small id="forgetV">0.18</small></div>
            <div class="row"><small>Social</small><input id="social" type="range" min="0" max="200" step="2" value="72" /><small id="socialV">72</small></div>
            <div class="row"><small>Separation</small><input id="separation" type="range" min="0" max="300" step="2" value="120" /><small id="separationV">120</small></div>
            <div class="row"><small>SepDist</small><input id="sepDist" type="range" min="5" max="80" step="1" value="28" /><small id="sepDistV">28</small></div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div class="hud" id="hud"></div>
  <div class="legend-mini" id="legendMini"></div>
  <div class="panel math collapsed" id="mathPanel">
    <div class="panel-header" id="mathHeader">
      <span class="panel-title">Game of Flies — Axioms</span>
      <button class="panel-toggle" id="mathToggle">▼</button>
    </div>
    <div class="panel-content">
      <div class="article-content" style="font-size:14px;">
        <p>This simulation follows a few simple axioms that couple motion, sensing, social dynamics, and morale.</p>
        <h3 style="margin:8px 0 4px;">Axioms</h3>
        <ul>
          <li><b>Agents</b>: Each fly has position x, velocity v, health h∈[0,1], and a 3‑channel opinion q=[q0,q1,q2].</li>
          <li><b>Fields</b>: Placed objects are <i>attractors</i> (houses) or <i>repellents</i> (hazards). They exert 1/r² forces and inject local sensing into the matching opinion channel.</li>
          <li><b>Self‑propulsion</b>: A motor + damping maintains motion with a minimum cruising speed; neutrals add correlated exploration noise.</li>
          <li><b>Awareness</b>: Opinion strength |q| raises sensitivity to fields and social terms; like‑minded neighbors <i>reinforce</i> opinions.</li>
          <li><b>Allegiance</b>: If max(qk) exceeds a threshold, allegiance=k. Allegiant flies orbit the nearest same‑channel flag (spring + swirl).</li>
          <li><b>Social + Combat</b>: Similar opinions align; opposed opinions anti‑align and can chase and attack at close range (health reduces speed).</li>
          <li><b>Morale</b>: Under local dominance and low health/weak belief, opinions drift toward the dominant side (allegiance can switch).</li>
          <li><b>Events</b>: Hazards pulse (expanding ring) that temporarily amplifies repulsion/damage on the ring.</li>
        </ul>
        <h3 style="margin:8px 0 4px;">Controls & Legend</h3>
        <ul>
          <li><b>Place</b>: Click to add Houses (attractors) or Hazards (repellents). Shift‑click removes nearest.</li>
          <li><b>HUD</b>: Shows counts, average health, and clashes. Thin colored lines indicate flag influence on flies.</li>
          <li><b>Panels</b>: Math toggles this help; Pause halts motion; Reset restores defaults; Clear removes objects.</li>
        </ul>
      </div>
    </div>
  </div>

  <script>
  (function(){
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let W=0, H=0, DPR=Math.max(1, Math.min(2, window.devicePixelRatio||1));
    const rand = (a,b)=>Math.random()*(b-a)+a;
    const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
    const dist2=(ax,ay,bx,by)=>{const dx=ax-bx,dy=ay-by;return dx*dx+dy*dy;};

    const state = {
      flies: [], // {x,y,vx,vy,info:[r,g,b], allegiance:-1, s:0}
      objs: [],  // {x,y,emoji,type:'flag', color?:'red'|'blue'|'white', qty?, maxQty?}
      grid: null, // spatial hash
      // Align names with usage in step(); prevent undefined -> NaN
      params: {
        N:220, kAttr:140, kRepel:180, commR:110, infoRate:1.2, speed:42, forget:0.18, beta:0.8,
        social:72, cohesion:36, separation:120, sepDist:28, hazardAlpha:1.2,
        // new dynamics
        gamma:1.2,               // velocity damping (s^-1)
        allyAlign:1.0,           // alignment with similar opinions
        enemyAntiAlign:0.7,      // anti-alignment with opposing opinions
        hostility:80,            // chase acceleration towards opponents
        attackRange:18,          // attack distance (px)
        attackDamage:0.35,       // damage per second at point-blank when both strong
        healRate:0.08,           // healing per second near friendly attractor
        healBase:0.015,          // baseline healing everywhere
        hazardDamage:0.08,       // damage per second near hazards
        // exploration for neutral flies
        explore:80,              // random exploration accel for neutral flies
        noiseTau:0.8,            // correlation time (s) for exploration direction
        // self-propulsion (active matter)
        motor:8.0,               // gain driving speed to target
        vmin:10,                 // minimum cruising speed
        // group morale / allegiance shift
        submissionRate:0.35,     // rate at which losing side shifts opinions
        dominanceThresh:1.25,    // local dominance ratio to trigger shift
        // home-orbit around owned flags
        homeR:80,                // preferred orbit radius around owned flag
        homeK:2.2,               // spring toward orbit radius
        homeSwirl:1.2,           // tangential swirl around home
        homeStick:4.0,           // extra inward clamp when far from home
        // event pulse (impact cycle) around hazards
        eventPeriod:3.5,         // seconds per pulse
        eventSigma:20,           // ring thickness for hazard boost
        eventBoost:1.8,          // multiplier for hazard at ring
        eventRmin:40,
        eventRmax:160,
        // compounding awareness
        awarenessGain:0.6,       // local reinforcement gain when among like-minded
        allegianceThresh:0.3     // threshold to set allegiance from opinion
      },
      paused:false,
      tool: { house:'stark', mode:'add' },
      conflicts:0,
    };

    // no legacy emoji mapping

    function resize(){
      W = canvas.clientWidth = window.innerWidth;
      H = canvas.clientHeight = window.innerHeight;
      canvas.width = Math.floor(W*DPR); canvas.height = Math.floor(H*DPR);
      canvas.style.width = W+'px'; canvas.style.height = H+'px';
      ctx.setTransform(DPR,0,0,DPR,0,0);
    }

    function initFlies(N){
      state.flies.length = 0;
      for(let i=0;i<N;i++){
        const x = Math.random()*W, y = Math.random()*H;
        const ang = rand(-Math.PI,Math.PI), sp=state.params.speed;
        const na = rand(-Math.PI,Math.PI);
        state.flies.push({ x, y, vx: Math.cos(ang)*sp, vy: Math.sin(ang)*sp, info:[0,0,0], allegiance:-1, s:0, h:1, anger:0, noiseX: Math.cos(na), noiseY: Math.sin(na) });
      }
    }

    // Defaults for reset
    const defaultParams = { N:220, kAttr:140, kRepel:180, commR:110, infoRate:1.2, speed:42, forget:0.18, beta:0.8, social:72, cohesion:36, separation:120, sepDist:28, hazardAlpha:1.2, gamma:1.2, allyAlign:1.0, enemyAntiAlign:0.7, hostility:80, attackRange:18, attackDamage:0.35, healRate:0.08, healBase:0.015, hazardDamage:0.08, explore:80, noiseTau:0.8, motor:8.0, vmin:10, submissionRate:0.35, dominanceThresh:1.25, homeR:80, homeK:2.2, homeSwirl:1.2, homeStick:4.0, eventPeriod:3.5, eventSigma:20, eventBoost:1.8, eventRmin:40, eventRmax:160, awarenessGain:0.6, allegianceThresh:0.3 };

    const HOUSES = {
      stark:      { type:'attractor', idx:1, color:'#6b7280', name:'Stark', emoji:'🐺' },
      lannister:  { type:'attractor', idx:0, color:'#b91c1c', name:'Lannister', emoji:'🦁' },
      targaryen:  { type:'attractor', idx:2, color:'#111827', name:'Targaryen', emoji:'🐉' },
      tyrell:     { type:'attractor', idx:1, color:'#065f46', name:'Tyrell', emoji:'🌿' },
      walkers:    { type:'repellent', idx:2, color:'#3b82f6', name:'Walkers', emoji:'🧟' },
      wildfire:   { type:'repellent', idx:1, color:'#10b981', name:'Wildfire', emoji:'🔥' },
    };

    function addObject(x,y,house){
      const h=HOUSES[house]||HOUSES.stark;
      state.objs.push({x,y,type:h.type, idx:h.idx, color:h.color, name:h.name, emoji:h.emoji, pulse:Math.random()});
    }

    function removeNearestObject(x,y){
      if(!state.objs.length) return;
      let best=-1, bd=1e9;
      for(let i=0;i<state.objs.length;i++){
        const o=state.objs[i]; const d=dist2(x,y,o.x,o.y);
        if(d<bd){ bd=d; best=i; }
      }
      if(best>=0) state.objs.splice(best,1);
    }

    // Spatial hash for comm links
    function buildGrid(cell=80){
      const cols=Math.max(1, Math.ceil((W||1)/cell)), rows=Math.max(1, Math.ceil((H||1)/cell));
      const g=Array.from({length:cols*rows},()=>[]);
      const idx=(x,y)=> clamp(Math.floor(x/cell),0,cols-1)+cols*clamp(Math.floor(y/cell),0,rows-1);
      for(let i=0;i<state.flies.length;i++){
        const f=state.flies[i];
        if (Number.isFinite(f.x) && Number.isFinite(f.y)) {
          g[idx(f.x,f.y)].push(i);
        }
      }
      state.grid={g,cell,cols,rows,idx};
    }

    function neighbors(i){
      const {g,cell,cols,rows,idx} = state.grid; const f=state.flies[i];
      const cx=clamp(Math.floor(f.x/cell),0,cols-1), cy=clamp(Math.floor(f.y/cell),0,rows-1);
      const res=[];
      for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++){
        const X=cx+dx, Y=cy+dy; if(X<0||Y<0||X>=cols||Y>=rows) continue;
        res.push(...g[X+cols*Y]);
      }
      return res;
    }

    // Color helpers — make display colors match placed objects
    function hexToRgb(hex){
      let h = String(hex||'').trim();
      if (h[0]==='#') h = h.slice(1);
      if (h.length===3) h = h.split('').map(c=>c+c).join('');
      if (h.length!==6) return [200,200,200];
      const num = parseInt(h,16); if (Number.isNaN(num)) return [200,200,200];
      return [(num>>16)&255, (num>>8)&255, num&255];
    }
    function nearestObjForChannel(x,y,ch){
      let best=null, bd=Infinity;
      for(const o of state.objs){
        if (o.idx!==ch) continue;
        const dx=o.x-x, dy=o.y-y; const d2=dx*dx+dy*dy;
        if (d2<bd){ bd=d2; best=o; }
      }
      return best;
    }
    function channelColorRgbForFly(f, ch){
      const o = nearestObjForChannel(f.x, f.y, ch);
      if (o && o.color) return hexToRgb(o.color);
      // Fallback palette aligned with typical house/hazard hues
      if (ch===0) return hexToRgb('#b91c1c'); // Lannister red
      if (ch===1) return hexToRgb('#065f46'); // Tyrell green
      return hexToRgb('#3b82f6');            // Walkers blue (default for ch=2)
    }

    function nearestAttractorForChannel(x,y,ch){
      let best=null, bd=Infinity;
      for(const o of state.objs){
        if (o.type!=='attractor' || o.idx!==ch) continue;
        const dx=o.x-x, dy=o.y-y; const d2=dx*dx+dy*dy; if(d2<bd){ bd=d2; best=o; }
      }
      return best;
    }

    function updateAllegiance(f){
      // allegiance = argmax positive info channel, else -1
      const thr = state.params.allegianceThresh||0.3;
      let k=0, m=f.info[0]||0; for(let i=1;i<3;i++){ const v=f.info[i]||0; if(v>m){ m=v; k=i; } }
      f.allegiance = (m>thr)? k : -1;
      return f.allegiance;
    }

    function parallelTransport(info, vx, vy, dt, speed){
      const v = Math.hypot(vx,vy); if (v<1e-3) return;
      const a = Math.atan2(vy,vx);
      const s = Math.min(1, v/Math.max(1,speed));
      const theta = 0.7 * s * dt; // mixing rate
      // skew-symmetric generator coefficients (velocity-dependent)
      const a1 = 0.9*Math.cos(a), a2=0.9*Math.sin(a), a3=0.6*Math.cos(2*a);
      const r=info[0], g=info[1], b=info[2];
      // d(info) = theta * G * info
      const dr = theta * ( -a1*g + a2*b);
      const dg = theta * (  a1*r - a3*b);
      const db = theta * ( -a2*r + a3*g);
      info[0]=clamp(r+dr,-1,1); info[1]=clamp(g+dg,-1,1); info[2]=clamp(b+db,-1,1);
    }

    function step(dt){
      const {kAttr,kRepel,commR,infoRate,speed,forget,beta,social,cohesion,separation,sepDist,hazardAlpha,gamma,allyAlign,enemyAntiAlign,hostility,attackRange,attackDamage,healRate,healBase,hazardDamage,explore,noiseTau,motor,vmin,submissionRate,dominanceThresh} = state.params;
      const commR2 = commR*commR;
      const N = state.flies.length; const ax = new Float32Array(N), ay = new Float32Array(N);
      let conflicts = 0;
      // forgetting and object forces with hazard dominance
      for(let i=0;i<N;i++){
        const f = state.flies[i];
        // forget
        f.info[0] = Math.max(-1, Math.min(1, f.info[0] - forget*f.info[0]*dt));
        f.info[1] = Math.max(-1, Math.min(1, f.info[1] - forget*f.info[1]*dt));
        f.info[2] = Math.max(-1, Math.min(1, f.info[2] - forget*f.info[2]*dt));
        let axAttr=0, ayAttr=0, axRep=0, ayRep=0, attrSum=0, repSum=0;
        const aware = Math.max(Math.abs(f.info[0]||0), Math.abs(f.info[1]||0), Math.abs(f.info[2]||0));
        const baseSens = 0.6 + 0.4*aware; // neutrals are less sensitive; informed feel stronger forces
        // dominant channel for healing affinity
        const a0=Math.abs(f.info[0]||0), a1=Math.abs(f.info[1]||0), a2=Math.abs(f.info[2]||0);
        let kdom=0, adom=a0; if(a1>adom){kdom=1; adom=a1;} if(a2>adom){kdom=2; adom=a2;}
        for(const o of state.objs){
          const dx=o.x-f.x, dy=o.y-f.y; const r2=dx*dx+dy*dy+25; const r=Math.sqrt(r2);
          const idx = o.idx;
          const reactSign = (o.type==='attractor')? 1 : -1;
          const sensScale = 1 + beta * (f.info[idx]||0) * reactSign;
          if (o.type==='attractor'){
            const mag = baseSens * sensScale * (kAttr / r2);
            axAttr += mag * dx / r; ayAttr += mag * dy / r; attrSum += (kAttr / r2);
            // healing near friendly banners
            if (r<48){
              const aff = (idx===kdom? 1.0 : 0.5);
              f.h = Math.min(1, f.h + healRate * aff * (1 - r/48) * dt);
            }
          } else {
            // hazard pulse boost (impact cycle)
            const period = Math.max(0.2, state.params.eventPeriod||3.5);
            o.pulse = (o.pulse||0) + dt/period; if (o.pulse>1) o.pulse-=1;
            const ringR = (state.params.eventRmin||40) + (state.params.eventRmax||160 - (state.params.eventRmin||40)) * o.pulse;
            const sigma = state.params.eventSigma||20;
            const boost = 1 + (state.params.eventBoost||1.5) * Math.exp(-((r-ringR)*(r-ringR))/(2*sigma*sigma));
            const mag = baseSens * sensScale * (kRepel / r2) * boost;
            axRep += -mag * dx / r; ayRep += -mag * dy / r; repSum += (kRepel / r2);
            // hazard hurts health at close range
            if (r<60){ f.h = Math.max(0, f.h - hazardDamage * (1 - r/60) * dt); }
          }
          // sensing update
          if (r<60){ const sgn = (o.type==='attractor')? 1 : -1; const v=(f.info[idx]||0) + sgn * 1.2*dt; f.info[idx] = Math.max(-1, Math.min(1, v)); }
        }
        updateAllegiance(f);
        // exploration for neutral flies: correlated random acceleration
        if (!Number.isFinite(f.noiseX) || !Number.isFinite(f.noiseY)){
          const ang = rand(-Math.PI,Math.PI); f.noiseX=Math.cos(ang); f.noiseY=Math.sin(ang);
        }
        const aExp = explore * (1 - aware);
        const kappa = Math.max(0.0001, noiseTau);
        const w = dt / kappa;
        f.noiseX = f.noiseX * (1 - w) + (Math.random()*2-1) * w;
        f.noiseY = f.noiseY * (1 - w) + (Math.random()*2-1) * w;
        const nrm = Math.hypot(f.noiseX, f.noiseY) || 1;
        ax[i] += aExp * (f.noiseX/nrm);
        ay[i] += aExp * (f.noiseY/nrm);
        const risk = repSum / (attrSum + 1e-6);
        const scaleA = 1/(1 + hazardAlpha * risk);
        const scaleR = 1 + hazardAlpha * risk;
        ax[i] += axAttr * scaleA + axRep * scaleR;
        ay[i] += ayAttr * scaleA + ayRep * scaleR;
        // baseline slow regeneration
        f.h = Math.min(1, f.h + healBase * dt);
      }
      // communication + social alignment
      buildGrid();
      // local channel influence accumulators for group-level allegiance shifts
      const lch0 = new Float32Array(N), lch1 = new Float32Array(N), lch2 = new Float32Array(N), lw = new Float32Array(N);
      const maxLinks=120; let drawn=0;
      for(let i=0;i<N;i++){
        const f = state.flies[i]; const vfi = Math.hypot(f.vx,f.vy)||1e-6; const ufi=[f.vx/vfi, f.vy/vfi];
        const neigh = neighbors(i);
        for(const j of neigh){ if(j<=i) continue; const g=state.flies[j];
          const d2 = (f.x-g.x)*(f.x-g.x)+(f.y-g.y)*(f.y-g.y); if(d2>commR2) continue; const d=Math.sqrt(d2);
          const phi = 1 - d/commR; if (phi<=0) continue;
          const vrel = Math.hypot(f.vx-g.vx, f.vy-g.vy);
          const psi = 1/(1+vrel/40);
          const k = infoRate * phi * psi;
          // accumulate local channel weights for both i and j
          lch0[i] += phi * Math.abs(g.info[0]||0); lch1[i] += phi * Math.abs(g.info[1]||0); lch2[i] += phi * Math.abs(g.info[2]||0); lw[i] += phi;
          lch0[j] += phi * Math.abs(f.info[0]||0); lch1[j] += phi * Math.abs(f.info[1]||0); lch2[j] += phi * Math.abs(f.info[2]||0); lw[j] += phi;
          const dr = ((g.info[0]||0)-(f.info[0]||0)) * k * dt;
          const dg = ((g.info[1]||0)-(f.info[1]||0)) * k * dt;
          const db = ((g.info[2]||0)-(f.info[2]||0)) * k * dt;
          f.info[0]=Math.max(-1, Math.min(1, (f.info[0]||0)+dr)); g.info[0]=Math.max(-1, Math.min(1, (g.info[0]||0)-dr));
          f.info[1]=Math.max(-1, Math.min(1, (f.info[1]||0)+dg)); g.info[1]=Math.max(-1, Math.min(1, (g.info[1]||0)-dg));
          f.info[2]=Math.max(-1, Math.min(1, (f.info[2]||0)+db)); g.info[2]=Math.max(-1, Math.min(1, (g.info[2]||0)-db));
          const infG = Math.max(Math.abs(g.info[0]||0), Math.abs(g.info[1]||0), Math.abs(g.info[2]||0));
          const infF = Math.max(Math.abs(f.info[0]||0), Math.abs(f.info[1]||0), Math.abs(f.info[2]||0));
          // similarity of opinions (cosine in info space)
          const qf=f.info, qg=g.info;
          const nf=Math.hypot(qf[0]||0,qf[1]||0,qf[2]||0), ng=Math.hypot(qg[0]||0,qg[1]||0,qg[2]||0);
          const sim = (nf>1e-3 && ng>1e-3)? ((qf[0]*qg[0]+qf[1]*qg[1]+qf[2]*qg[2])/(nf*ng)) : 0;
          const wBase = social * phi * psi * 0.5;
          if (sim>=0){
            const wS = allyAlign * wBase * (0.5 + 0.5*sim);
            const vgj = Math.hypot(g.vx,g.vy)||1e-6; const ugj=[g.vx/vgj, g.vy/vgj];
            ax[i] += (ugj[0]-ufi[0]) * wS * infG; ay[i] += (ugj[1]-ufi[1]) * wS * infG;
            ax[j] += (ufi[0]-ugj[0]) * wS * infF; ay[j] += (ufi[1]-ugj[1]) * wS * infF;
          } else {
            const wE = enemyAntiAlign * phi * psi * (0.5 + 0.5*(-sim)) * 0.5;
            const vgj = Math.hypot(g.vx,g.vy)||1e-6; const ugj=[g.vx/vgj, g.vy/vgj];
            ax[i] -= (ugj[0]-ufi[0]) * wE * infG; ay[i] -= (ugj[1]-ufi[1]) * wE * infG;
            ax[j] -= (ufi[0]-ugj[0]) * wE * infF; ay[j] -= (ufi[1]-ugj[1]) * wE * infF;
          }
          // hostility: chase and attack when opposed and strong
          let kfi=0, sfi=Math.abs(f.info[0]||0); if(Math.abs(f.info[1]||0)>sfi){kfi=1; sfi=Math.abs(f.info[1]||0);} if(Math.abs(f.info[2]||0)>sfi){kfi=2; sfi=Math.abs(f.info[2]||0);}
          let kgi=0, sgi=Math.abs(g.info[0]||0); if(Math.abs(g.info[1]||0)>sgi){kgi=1; sgi=Math.abs(g.info[1]||0);} if(Math.abs(g.info[2]||0)>sgi){kgi=2; sgi=Math.abs(g.info[2]||0);}
          if (kfi!==kgi && sfi>0.65 && sgi>0.65){
            const dx=g.x-f.x, dy=g.y-f.y; const invd = 1/(d+1e-6);
            const chase = hostility * phi * psi;
            ax[i] += dx*invd * chase; ay[i] += dy*invd * chase;
            ax[j] -= dx*invd * chase; ay[j] -= dy*invd * chase;
            if (d < attackRange){
              conflicts++;
              const dmg = attackDamage * (0.5 + 0.5*phi) * (sfi*sgi);
              f.anger = Math.min(1, f.anger + 0.7*phi);
              g.anger = Math.min(1, g.anger + 0.7*phi);
              f.h = Math.max(0, f.h - dmg*dt);
              g.h = Math.max(0, g.h - dmg*dt);
            }
          }
          if (drawn<maxLinks){
            const mr = Math.abs(f.info[0]-g.info[0]);
            const mg = Math.abs(f.info[1]-g.info[1]);
            const mb = Math.abs(f.info[2]-g.info[2]);
            const alpha = 0.05 + 0.2*Math.max(mr,mg,mb);
            ctx.save(); ctx.globalAlpha = alpha;
            ctx.strokeStyle = `rgb(${Math.floor(200*mr)}, ${Math.floor(200*mg)}, ${Math.floor(200*mb)})`;
            ctx.beginPath(); ctx.moveTo(f.x,f.y); ctx.lineTo(g.x,g.y); ctx.stroke(); ctx.restore();
            drawn++;
          }
        }
      }
      // compounding awareness: reinforce opinions when surrounded by like-minded
      for(let i=0;i<N;i++){
        const f=state.flies[i]; const w = lw[i]; if (w>1e-3){
          const g = state.params.awarenessGain||0;
          const s0 = lch0[i]/w, s1 = lch1[i]/w, s2 = lch2[i]/w;
          if ((f.info[0]||0) > 0) f.info[0] = clamp((f.info[0]||0) + g * s0 * (1-Math.abs(f.info[0]||0)) *  dt, -1, 1);
          if ((f.info[1]||0) > 0) f.info[1] = clamp((f.info[1]||0) + g * s1 * (1-Math.abs(f.info[1]||0)) *  dt, -1, 1);
          if ((f.info[2]||0) > 0) f.info[2] = clamp((f.info[2]||0) + g * s2 * (1-Math.abs(f.info[2]||0)) *  dt, -1, 1);
        }
      }
      // group-level allegiance shift based on local dominance, health, and weak belief
      for(let i=0;i<N;i++){
        const f = state.flies[i];
        const s0 = lch0[i], s1 = lch1[i], s2 = lch2[i];
        const arr = [s0,s1,s2];
        let kd=0, md=arr[0], sec=0;
        for(let k=1;k<3;k++){ const v=arr[k]; if(v>md){ sec=md; md=v; kd=k; } else if(v>sec){ sec=v; } }
        const ratio = (md+1e-6)/(sec+1e-6);
        // current dominant channel of fly
        let kf=0, mf=Math.abs(f.info[0]||0); if(Math.abs(f.info[1]||0)>mf){ kf=1; mf=Math.abs(f.info[1]||0);} if(Math.abs(f.info[2]||0)>mf){ kf=2; mf=Math.abs(f.info[2]||0);} 
        if (kd!==kf && ratio>dominanceThresh){
          const pressure = submissionRate * (ratio - dominanceThresh) * (lw[i]/(lw[i]+1)) * (1 - (f.h||0)) * (1 - mf);
          // shift opinions toward kd, away from kf
          const signF = (f.info[kf]||0) >= 0 ? 1 : -1;
          const signD = (f.info[kd]||0) >= 0 ? 1 : -1;
          f.info[kf] = clamp((f.info[kf]||0) - signF * pressure * 0.6 * dt, -1, 1);
          f.info[kd] = clamp((f.info[kd]||0) + signD * pressure * dt, -1, 1);
        }
      }
      // boids-style cohesion and separation (awareness weighted) + home-orbit force
      for(let i=0;i<N;i++){
        const f = state.flies[i];
        const neigh = neighbors(i);
        let cx=0, cy=0, wsum=0; // cohesion
        let sx=0, sy=0;        // separation
        for(const j of neigh){ if(j===i) continue; const g=state.flies[j];
          const dx=g.x-f.x, dy=g.y-f.y; const d2=dx*dx+dy*dy; const d=Math.sqrt(d2)+1e-6;
          const phi = Math.max(0, 1 - d/commR);
          const inf = Math.max(Math.abs(g.info[0]||0), Math.abs(g.info[1]||0), Math.abs(g.info[2]||0));
          const w = phi * (0.5+0.5*inf);
          cx += g.x * w; cy += g.y * w; wsum += w;
          const sep = Math.max(0, sepDist - d);
          if (sep>0){ sx += -(dx/d) * (sep*sep/d); sy += -(dy/d) * (sep*sep/d); }
        }
        if (wsum>0){
          const tx = (cx/wsum) - f.x; const ty = (cy/wsum) - f.y;
          ax[i] += cohesion * tx * 0.0015;
          ay[i] += cohesion * ty * 0.0015;
        }
        ax[i] += separation * sx * 0.0025;
        ay[i] += separation * sy * 0.0025;
        // home-orbit: flies with allegiance orbit near the nearest owned flag
        if (f.allegiance!=null && f.allegiance>=0){
          // find nearest attractor with same channel index
          let best=null, bd=Infinity;
          for(const o of state.objs){ if (o.type!=='attractor') continue; if (o.idx!==f.allegiance) continue; const d2=(o.x-f.x)*(o.x-f.x)+(o.y-f.y)*(o.y-f.y); if(d2<bd){ bd=d2; best=o; } }
          if (best){
            const dx=best.x-f.x, dy=best.y-f.y; const r=Math.hypot(dx,dy)||1; const ux=dx/r, uy=dy/r;
            const dr = r - (state.params.homeR||80);
            const kspring = state.params.homeK||2.2; const swirl = state.params.homeSwirl||1.2;
            ax[i] += kspring * dr * ux + swirl * (-uy);
            ay[i] += kspring * dr * uy + swirl * ( ux);
            // extra inward clamp when too far from home orbit
            const stick = state.params.homeStick||0;
            if (r > 1.7*(state.params.homeR||80)){
              const extra = stick * (r/(state.params.homeR||80) - 1.7);
              ax[i] += extra * ux; ay[i] += extra * uy;
            }
          }
        }
      }
      // self-propulsion to maintain motion
      for(let i=0;i<N;i++){
        const f=state.flies[i];
        const v=Math.hypot(f.vx,f.vy);
        const vt = Math.max(vmin, speed * (0.6 + 0.4*(f.h||0)));
        if (v>1e-4){
          ax[i] += motor * (vt - v) * (f.vx/v);
          ay[i] += motor * (vt - v) * (f.vy/v);
        } else {
          // kick in exploration direction
          const nrm = Math.hypot(f.noiseX||1, f.noiseY||0) || 1;
          ax[i] += motor * vt * ( (f.noiseX||1)/nrm );
          ay[i] += motor * vt * ( (f.noiseY||0)/nrm );
        }
      }
      // integrate
      for(let i=0;i<N;i++){
        const f=state.flies[i];
        // apply damping
        f.vx = (f.vx + ax[i]*dt) * (1 - Math.max(0, Math.min(0.95, gamma*dt)));
        f.vy = (f.vy + ay[i]*dt) * (1 - Math.max(0, Math.min(0.95, gamma*dt)));
        parallelTransport(f.info, f.vx, f.vy, dt, speed);
        // health affects max speed; keep a minimum cruise
        const v=Math.hypot(f.vx,f.vy)||1; const vmax=Math.max(vmin, speed * (0.6 + 0.4*(f.h||0)));
        if(v>vmax){ f.vx=f.vx/v*vmax; f.vy=f.vy/v*vmax; }
        f.x += f.vx*dt; f.y += f.vy*dt;
        if (f.x<4){ f.x=4; f.vx=Math.abs(f.vx); }
        if (f.x>W-4){ f.x=W-4; f.vx=-Math.abs(f.vx); }
        if (f.y<4){ f.y=4; f.vy=Math.abs(f.vy); }
        if (f.y>H-4){ f.y=H-4; f.vy=-Math.abs(f.vy); }
        // decay anger effect
        f.anger = Math.max(0, (f.anger||0) - 1.5*dt);
        // respawn on zero health
        if ((f.h||0) <= 0){
          f.x = Math.random()*W; f.y = Math.random()*H;
          const ang = rand(-Math.PI,Math.PI), sp=speed*0.5; f.vx=Math.cos(ang)*sp; f.vy=Math.sin(ang)*sp;
          f.info[0]*=0.4; f.info[1]*=0.4; f.info[2]*=0.4; f.h=1; f.anger=0;
        }
      }
      state.conflicts = conflicts;
    }

    function draw(){
      ctx.clearRect(0,0,W,H);
      // objects
      for(const o of state.objs){
        ctx.save(); ctx.font = '20px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
        // draw flag banner and emoji
        const col = (typeof o.color==='string' && o.color) ? o.color : '#e5e7eb';
        const w=28, h=16, pole=10;
        ctx.globalAlpha=1; ctx.strokeStyle='#888'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(o.x-pole, o.y-h/2); ctx.lineTo(o.x-pole, o.y+h/2+6); ctx.stroke();
        ctx.fillStyle=col; ctx.strokeStyle='#222'; ctx.lineWidth=1;
        ctx.beginPath(); ctx.rect(o.x-pole+2, o.y-h/2, w, h); ctx.fill(); ctx.stroke();
        // emoji label
        if (o.emoji){ ctx.font='18px Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji, system-ui'; ctx.fillText(o.emoji, o.x-pole+w+10, o.y); }
        // hazard impact cycle ring
        if (o.type==='repellent'){
          const period=Math.max(0.2, state.params.eventPeriod||3.5);
          o.pulse = (o.pulse||0); // updated in step
          const rmin=state.params.eventRmin||40, rmax=state.params.eventRmax||160;
          const ring=rmin+(rmax-rmin)*(o.pulse||0);
          ctx.strokeStyle=col; ctx.globalAlpha=0.25; ctx.lineWidth=1.5; ctx.beginPath(); ctx.arc(o.x,o.y, ring, 0, Math.PI*2); ctx.stroke();
        }
        ctx.restore();
      }
      // flies with influence lines, info dots (RGB), and direction hint
      for(const f of state.flies){
        // influence line from flag to fly (based on allegiance or dominant positive channel)
        let ch = (f.allegiance!=null && f.allegiance>=0)? f.allegiance : -1;
        if (ch<0){
          let m=-1, k=-1; for(let i=0;i<3;i++){ const v=f.info[i]||0; if(v>m){ m=v; k=i; } }
          if (m>0.15) ch=k;
        }
        if (ch>=0){
          const o = nearestAttractorForChannel(f.x, f.y, ch);
          if (o){
            const w = Math.max(0, f.info[ch]||0);
            const rgb = hexToRgb(o.color||'#888888');
            ctx.save();
            ctx.globalAlpha = 0.12 + 0.55*Math.min(1,w);
            ctx.strokeStyle = `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`;
            ctx.lineWidth = 0.7;
            ctx.beginPath(); ctx.moveTo(o.x, o.y); ctx.lineTo(f.x, f.y); ctx.stroke();
            ctx.restore();
          }
        }
        // body
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.beginPath(); ctx.arc(f.x, f.y, 3.8, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.lineWidth = 0.6; ctx.stroke();
        // under-attack ring
        if ((f.anger||0) > 0.05){
          ctx.strokeStyle = `rgba(220,40,30,${0.25+0.45*Math.min(1,f.anger)})`;
          ctx.lineWidth = 1.2; ctx.beginPath(); ctx.arc(f.x, f.y, 6.2, 0, Math.PI*2); ctx.stroke();
        }
        // direction hint
        const vmag = Math.hypot(f.vx,f.vy);
        if (vmag>1e-2){
          const ux=f.vx/vmag, uy=f.vy/vmag; const L=7;
          const a0=Math.abs(f.info[0]||0), a1=Math.abs(f.info[1]||0), a2=Math.abs(f.info[2]||0);
          let kdom=0, ad=a0; if(a1>ad){kdom=1; ad=a1;} if(a2>ad){kdom=2; ad=a2;}
          const c = channelColorRgbForFly(f, kdom);
          ctx.strokeStyle = `rgba(${c[0]},${c[1]},${c[2]},${0.25+0.45*ad})`;
          ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(f.x, f.y); ctx.lineTo(f.x+ux*L, f.y+uy*L); ctx.stroke();
        }
        // info dots around
        const R=5.6;
        const angs=[-Math.PI/2, -Math.PI/2 + 2*Math.PI/3, -Math.PI/2 + 4*Math.PI/3];
        for(let k=0;k<3;k++){
          const a=angs[k]; const x=f.x+R*Math.cos(a), y=f.y+R*Math.sin(a);
          const val = Math.abs(f.info[k]||0);
          const s=1.2+2.2*val;
          const c = channelColorRgbForFly(f, k);
          ctx.fillStyle=`rgba(${c[0]},${c[1]},${c[2]},${0.25+0.6*val})`;
          if ((f.info[k]||0) < 0){ ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.lineWidth=0.8; } else { ctx.strokeStyle='rgba(255,255,255,0.5)'; ctx.lineWidth=0.5; }
          ctx.beginPath(); ctx.arc(x,y, s, 0, Math.PI*2); ctx.fill();
          ctx.stroke();
        }
        // health bar above the fly
        const hp = Math.max(0, Math.min(1, f.h||0));
        const bw=12, bh=2, bx=f.x-bw/2, by=f.y-9;
        ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.fillRect(bx,by,bw,bh);
        const r=Math.floor(220*(1-hp)), g=Math.floor(180*hp), b=40;
        ctx.fillStyle=`rgba(${r},${g},${b},0.9)`; ctx.fillRect(bx,by, bw*hp, bh);
      }
    }

    // HUD
    function hud(){
      const el=document.getElementById('hud');
      // mean info vector
      let mr=0,mg=0,mb=0; for(const f of state.flies){ mr+=f.info[0]; mg+=f.info[1]; mb+=f.info[2]; }
      const n=state.flies.length||1; mr/=n; mg/=n; mb/=n;
      const concept = state.tool.house || 'object';
      // health summary
      let mh=0; for(const f of state.flies){ mh += (f.h||0); } mh/=n;
      // object breakdown
      let nAt=0, nHz=0; for(const o of state.objs){ if(o.type==='attractor') nAt++; else nHz++; }
      // allegiance counts
      let c0=0,c1=0,c2=0,neu=0; for(const f of state.flies){ if(f.allegiance===0) c0++; else if(f.allegiance===1) c1++; else if(f.allegiance===2) c2++; else neu++; }
      // status line
      const status = state.paused? 'Paused' : (state.objs.length===0? 'Exploring' : ((state.conflicts||0)>0? 'Engaged' : 'Flocking'));
      el.innerHTML = `status=${status} • flies=${state.flies.length} • flags=${nAt} • hazards=${nHz} • A[0,1,2]=[${c0},${c1},${c2}] • neutral=${neu} • ⟨q⟩=[${mr.toFixed(2)}, ${mg.toFixed(2)}, ${mb.toFixed(2)}] • ⟨health⟩=${mh.toFixed(2)} • clashes=${state.conflicts||0}`+
                     `<div class="legend">Click to ${state.tool.mode==='add'?'place':'remove'} ${concept}. Shift‑click removes. Hover flags for awareness count.</div>`;
    }

    // Interaction
    function pickHouse(btn){
      document.querySelectorAll('.tool-btn[data-house]').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      state.tool.house = btn.getAttribute('data-house');
    }
    document.querySelectorAll('.tool-btn[data-house]').forEach(btn=>{
      btn.addEventListener('click', ()=> pickHouse(btn));
    });
    pickHouse(document.querySelector('.tool-btn[data-house="stark"]'));
    const modeAdd=document.getElementById('modeAdd');
    const modeRemove=document.getElementById('modeRemove');
    function setMode(m){ state.tool.mode=m; modeAdd.classList.toggle('active', m==='add'); modeRemove.classList.toggle('active', m==='remove'); }
    modeAdd.addEventListener('click', ()=>setMode('add'));
    modeRemove.addEventListener('click', ()=>setMode('remove'));
    setMode('add');

    canvas.addEventListener('click', (e)=>{
      const r=canvas.getBoundingClientRect(); const x=(e.clientX-r.left), y=(e.clientY-r.top);
      if (e.shiftKey || state.tool.mode==='remove') removeNearestObject(x,y);
      else addObject(x,y,state.tool.house);
    });

    // Controls
    function bindRange(id, prop, fmt=(v)=>v){
      const el=document.getElementById(id); const lab=document.getElementById(id+'V');
      function upd(){ state.params[prop] = (id==='info'? parseFloat(el.value) : +el.value); lab.textContent = fmt(state.params[prop]); }
      el.addEventListener('input', ()=>{ upd(); if(prop==='N'){ initFlies(state.params.N); } });
      upd();
    }
    bindRange('flies','N');
    bindRange('attr','kAttr');
    bindRange('comm','commR');
    bindRange('info','infoRate', v=>v.toFixed(2));
    bindRange('forget','forget', v=>v.toFixed(2));
    bindRange('social','social');
    bindRange('cohesion','cohesion');
    bindRange('separation','separation');
    bindRange('sepDist','sepDist');

    document.getElementById('togglePause').addEventListener('click', ()=>{ state.paused=!state.paused; document.getElementById('togglePause').textContent = state.paused?'Resume':'Pause'; });
    document.getElementById('clear').addEventListener('click', ()=>{ state.objs.length=0; state.flies.forEach(f=>{ f.info[0]=0; f.info[1]=0; f.info[2]=0; f.s=0; f.allegiance=-1; }); });
    // reset defaults
    document.getElementById('resetSettings').addEventListener('click', ()=>{
      const set=(id,val)=>{ const el=document.getElementById(id); if(!el) return; el.value=String(val); el.dispatchEvent(new Event('input',{bubbles:true})); };
      const d= { N:220, kAttr:140, commR:110, infoRate:1.2, speed:42, forget:0.18, social:72, cohesion:36, separation:120, sepDist:28 };
      set('flies', d.N); set('attr', d.kAttr); set('comm', d.commR); set('info', d.infoRate); set('forget', d.forget);
      set('social', d.social); set('cohesion', d.cohesion); set('separation', d.separation); set('sepDist', d.sepDist);
      saveSettings();
    });
    // math panel toggle
    const mathPanel=document.getElementById('mathPanel');
    function toggleMath(){ mathPanel.classList.toggle('collapsed'); }
    document.getElementById('mathToggle').addEventListener('click', toggleMath);
    document.getElementById('mathHeader').addEventListener('click', toggleMath);
    document.getElementById('toggleMath').addEventListener('click', toggleMath);
    // controls panel + tabs
    const controlsPanel=document.getElementById('controlsPanel');
    document.getElementById('controlsToggle').addEventListener('click', ()=> controlsPanel.classList.toggle('collapsed'));
    document.getElementById('controlsHeader').addEventListener('click', ()=> controlsPanel.classList.toggle('collapsed'));
    const tabTools=document.getElementById('tabTools');
    const tabSettings=document.getElementById('tabSettings');
    const toolsSection=document.getElementById('toolsSection');
    const settingsSection=document.getElementById('settingsSection');
    function setTab(which){
      const tools = which==='tools';
      tabTools.classList.toggle('active', tools);
      tabSettings.classList.toggle('active', !tools);
      toolsSection.classList.toggle('active', tools);
      settingsSection.classList.toggle('active', !tools);
    }
    tabTools.addEventListener('click', ()=> setTab('tools'));
    tabSettings.addEventListener('click', ()=> setTab('settings'));
    setTab('tools');

    // Persist settings
    function saveSettings(){
      try{
        const p=state.params;
        // Store with current canonical keys; include extended params
        const data={ N:p.N, kAttr:p.kAttr, kRepel:p.kRepel, commR:p.commR, infoRate:p.infoRate, speed:p.speed, forget:p.forget, beta:p.beta, social:p.social, cohesion:p.cohesion, separation:p.separation, sepDist:p.sepDist, hazardAlpha:p.hazardAlpha, gamma:p.gamma, allyAlign:p.allyAlign, enemyAntiAlign:p.enemyAntiAlign, hostility:p.hostility, attackRange:p.attackRange, attackDamage:p.attackDamage, healRate:p.healRate, healBase:p.healBase, hazardDamage:p.hazardDamage, explore:p.explore, noiseTau:p.noiseTau, motor:p.motor, vmin:p.vmin, submissionRate:p.submissionRate, dominanceThresh:p.dominanceThresh, homeR:p.homeR, homeK:p.homeK, homeSwirl:p.homeSwirl, homeStick:p.homeStick, eventPeriod:p.eventPeriod, eventSigma:p.eventSigma, eventBoost:p.eventBoost, eventRmin:p.eventRmin, eventRmax:p.eventRmax, awarenessGain:p.awarenessGain, allegianceThresh:p.allegianceThresh };
        localStorage.setItem('infoflies.settings', JSON.stringify(data));
      }catch(e){}
    }
    function loadSettings(){
      try{
        const raw=localStorage.getItem('infoflies.settings'); if(!raw) return; const d=JSON.parse(raw);
        const set=(id,val)=>{ const el=document.getElementById(id); if(!el) return; el.value=String(val); el.dispatchEvent(new Event('input',{bubbles:true})); };
        // Backward compatibility with older keys (kFlag/influence)
        const get=(newKey, oldKey)=> (d[newKey]!==undefined? d[newKey] : d[oldKey]);
        const mappings = [
          ['flies', 'N', null],
          ['attr', 'kAttr', 'kFlag'],
          ['comm', 'commR', null],
          ['info', 'infoRate', 'influence'],
          ['forget', 'forget', null],
          ['social', 'social', null],
          ['cohesion', 'cohesion', null],
          ['separation', 'separation', null],
          ['sepDist', 'sepDist', null],
        ];
        for(const [id, nk, ok] of mappings){
          const v = get(nk, ok);
          if(v!==undefined) set(id, v);
        }
        // Directly merge additional params (no UI sliders yet)
        const keys=['kRepel','beta','hazardAlpha','gamma','allyAlign','enemyAntiAlign','hostility','attackRange','attackDamage','healRate','healBase','hazardDamage','speed','explore','noiseTau','motor','vmin','submissionRate','dominanceThresh','homeR','homeK','homeSwirl','homeStick','eventPeriod','eventSigma','eventBoost','eventRmin','eventRmax','awarenessGain','allegianceThresh'];
        for(const k of keys){ if (d[k]!==undefined) state.params[k]=d[k]; }
      }catch(e){}
    }
    // attach save to sliders
    document.querySelectorAll('#settingsSection input[type=range]').forEach(el=> el.addEventListener('input', saveSettings));
    loadSettings();

    // Loop
    let last=performance.now();
    function loop(now){
      const dt = Math.min(50, now-last)/1000; last=now;
      if(!state.paused){ step(dt); }
      draw(); hud(); updateLegend(); requestAnimationFrame(loop);
    }
    // Hover tooltip on flags
    const tip=document.createElement('div'); tip.id='flagTip'; tip.className='flag-tip'; document.body.appendChild(tip);
    canvas.addEventListener('mousemove', (e)=>{
      const r=canvas.getBoundingClientRect(); const mx=e.clientX-r.left, my=e.clientY-r.top;
      let best=-1, bd=900; for(let i=0;i<state.objs.length;i++){ const o=state.objs[i]; const d2=(o.x-mx)*(o.x-mx)+(o.y-my)*(o.y-my); if(d2<bd){ bd=d2; best=i; } }
      if (best>=0 && bd < 1600){
        const o=state.objs[best]; let aware=0; for(const f of state.flies){ const v=Math.abs(f.info[o.idx]||0); if(v>0.6) aware++; }
        tip.innerHTML = `${o.name} • channel ${o.idx} • aware: ${aware}`;
        tip.style.left = `${e.clientX+12}px`; tip.style.top = `${e.clientY+12}px`; tip.style.display='block';
      } else { tip.style.display='none'; }
    });
    function updateLegend(){
      const el=document.getElementById('legendMini'); if(!el) return;
      const S=[{c:0,b:0},{c:0,b:0},{c:0,b:0}]; let neutral=0;
      for(const f of state.flies){
        if (f.allegiance!=null && f.allegiance>=0){
          const k=f.allegiance|0; S[k].c++; S[k].b += Math.min(1, Math.abs(f.info[k]||0));
        } else { neutral++; }
      }
      const avg=(x)=> x.c? (x.b/x.c).toFixed(2) : '0.00';
      const cols=['#b91c1c','#065f46','#3b82f6'];
      const ems=['🦁','🌿','🐉/🧟'];
      el.innerHTML = `
        <div class="legend-row"><span class="swatch" style="background:${cols[0]}"></span> ${ems[0]} ch0: ${S[0].c} • |q|=${avg(S[0])}</div>
        <div class="legend-row"><span class="swatch" style="background:${cols[1]}"></span> ${ems[1]} ch1: ${S[1].c} • |q|=${avg(S[1])}</div>
        <div class="legend-row"><span class="swatch" style="background:${cols[2]}"></span> ${ems[2]} ch2: ${S[2].c} • |q|=${avg(S[2])}</div>
        <div class="legend-row">Neutral: ${neutral}</div>
      `;
    }

    // Boot
    function start(){ resize(); initFlies(state.params.N); requestAnimationFrame(loop); }
    window.addEventListener('resize', ()=>{ resize(); });
    start();
  })();
  </script>
</body>
</html>
