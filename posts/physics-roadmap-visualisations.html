<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>First Principles Physics: Spacetime, Fields, and Symmetry — Live Visuals</title>
  <meta name="description" content="A self‑contained, first‑principles walkthrough of spacetime, fields, symmetry, Higgs, mixing, and lensing — with faithful equations and interactive canvases." />
  <link rel="stylesheet" href="../style.css" />
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [["$","$"],["\\(","\\)"]],
        displayMath: [["$$","$$"],["\\[","\\]"]],
        packages: {'[+]': ['base','ams']},
        processEscapes: true
      },
      options: { skipHtmlTags: ['script','noscript','style','textarea','pre'] }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  <style>
    .section { margin: 28px 0 40px 0; padding-bottom: 20px; border-bottom: 1px solid var(--border); }
    .demo { background: #fff; border: 1px solid var(--border); border-radius: 10px; padding: 14px; max-width: 820px; margin: 12px auto; }
    canvas.demo-canvas { display:block; margin:10px auto; border:1px solid var(--border); border-radius:8px; background:#fff; }
    .controls { display:flex; flex-wrap:wrap; gap:8px; justify-content:center; margin-top:8px; }
    .controls label { font-size: 12px; color: var(--muted); }
    .controls input[type=range] { width: 160px; accent-color: var(--accent); }
    .kpis { display:grid; grid-template-columns: repeat(auto-fit, minmax(140px,1fr)); gap:10px; margin-top:10px; }
    .kpi { background:#fafafa; border:1px solid var(--border); border-radius:8px; padding:8px; text-align:center; }
    .kpi b { display:block; font-size: 0.75em; color: var(--muted); text-transform: uppercase; letter-spacing: 0.8px; }
    .kpi .val { font-weight:700; color: var(--text); margin-top:4px; }
    .note { max-width: 820px; margin: 8px auto 0 auto; color: var(--muted); font-size: 0.95em; }
  </style>
  <script>
    (function(){
      const reduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      // 1) Lorentz boost visual (Minkowski diagram)
      function lorentzSection(){
        const cv = document.getElementById('lorentz'); if(!cv) return;
        const ctx = cv.getContext('2d');
        const W = cv.width = 700, H = cv.height = 380;
        let v = 0.6; // units with c=1

        function gamma(v){ return 1/Math.sqrt(1-v*v); }
        function Lx(x,t){ return gamma(v)*(x - v*t); }
        function Lt(x,t){ return gamma(v)*(t - v*x); }

        function draw(){
          ctx.clearRect(0,0,W,H);
          ctx.save();
          // center
          const cx=W*0.5, cy=H*0.8; // t upward
          const scale=50; // pixels per unit

          // axes
          ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1;
          ctx.beginPath(); ctx.moveTo(10,cy); ctx.lineTo(W-10,cy); ctx.stroke(); // x-axis (t=0)
          ctx.beginPath(); ctx.moveTo(cx,H-10); ctx.lineTo(cx,10); ctx.stroke(); // t-axis (x=0)

          // light cone (45°): t=|x|
          ctx.strokeStyle = 'rgba(255,165,0,0.9)';
          ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+scale*2, cy-2*scale); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx-scale*2, cy-2*scale); ctx.stroke();

          // Rest frame grid (hyperbolas as guide: t^2 - x^2 = const)
          ctx.strokeStyle = 'rgba(0,0,0,0.08)';
          for(let k=1;k<=3;k++){
            const s = k*1.0;
            // timelike hyperbola t = +sqrt(x^2 + s)
            ctx.beginPath();
            for(let x=-3;x<=3;x+=0.02){
              const t = Math.sqrt(x*x+s);
              const X = cx + x*scale, T = cy - t*scale; if(x===-3) ctx.moveTo(X,T); else ctx.lineTo(X,T);
            }
            ctx.stroke();
            // spacelike hyperbola x = +sqrt(t^2 + s)
            ctx.beginPath();
            for(let t=0;t<=3;t+=0.02){
              const x = Math.sqrt(t*t+s);
              const X = cx + x*scale, T = cy - t*scale; if(t===0) ctx.moveTo(X,T); else ctx.lineTo(X,T);
            }
            ctx.stroke();
          }

          // Boosted axes: x' and t'
          const g = gamma(v);
          // t' axis: x = v t -> line through origin with slope dt/dx = 1/v in (x,t)
          ctx.strokeStyle = 'rgba(0,120,255,0.9)'; ctx.lineWidth = 1.2;
          ctx.beginPath();
          for(let t=0;t<=3;t+=0.01){
            const x = v*t; const X=cx+x*scale, T=cy-t*scale; if(t===0) ctx.moveTo(X,T); else ctx.lineTo(X,T);
          }
          ctx.stroke();
          // x' axis: t = v x -> line through origin with slope dt/dx = v
          ctx.beginPath();
          for(let x=-3;x<=3;x+=0.01){
            const t = v*x; const X=cx+x*scale, T=cy-t*scale; if(x===-3) ctx.moveTo(X,T); else ctx.lineTo(X,T);
          }
          ctx.stroke();

          // sample events and their transforms
          const events = [
            {x:1.0, t:1.0}, {x:-1.0,t:1.4}, {x:0.5, t:2.2}, {x: -1.2, t: 0.8}
          ];
          // original events (black)
          for(const e of events){
            const X = cx + e.x*scale, T = cy - e.t*scale;
            ctx.fillStyle = '#222'; ctx.beginPath(); ctx.arc(X,T,3,0,Math.PI*2); ctx.fill();
          }
          // boosted coordinates (blue squares)
          for(const e of events){
            const xp = Lx(e.x,e.t), tp = Lt(e.x,e.t);
            const X = cx + xp*scale, T = cy - tp*scale;
            ctx.fillStyle = 'rgba(0,120,255,0.9)'; ctx.fillRect(X-2,T-2,4,4);
          }

          // labels
          ctx.fillStyle = '#666'; ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, monospace';
          ctx.fillText('x', W-20, cy-6); ctx.fillText('t', cx+6, 18);
          ctx.fillStyle = 'rgba(0,120,255,0.9)';
          ctx.fillText("t' axis", cx+60, cy-80); ctx.fillText("x' axis", cx+120, cy-20);

          ctx.restore();
          document.getElementById('lorentzV').textContent = v.toFixed(2) + ' c';
          document.getElementById('lorentzGamma').textContent = g.toFixed(3);
        }

        function setV(val){ v = Math.max(-0.95, Math.min(0.95, parseFloat(val))); draw(); }
        draw();
        return { setV };
      }

      // 2) Spinor double-cover (SU(2) -> SO(3))
      function spinorSection(){
        const cv = document.getElementById('spinor'); if(!cv) return; const ctx=cv.getContext('2d');
        const W=cv.width=540, H=cv.height=260; let ang=0;
        function draw(){
          ctx.clearRect(0,0,W,H);
          const cx=W*0.5, cy=H*0.6, R=80;
          // Bloch equator circle
          ctx.strokeStyle='#ddd'; ctx.beginPath(); ctx.arc(cx,cy,R,0,Math.PI*2); ctx.stroke();
          // pointer showing physical orientation (needs 2π)
          const bx=cx+Math.cos(ang)*R, by=cy-Math.sin(ang)*R;
          ctx.strokeStyle='rgba(0,120,255,0.9)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(bx,by); ctx.stroke();
          // spinor phase for |up> under rotation around z: ψ → e^{-i θ/2} |up>
          const px=cx+Math.cos(ang/2)*R*0.7, py=cy-1.2*R;
          ctx.strokeStyle='rgba(26,137,23,0.9)'; ctx.beginPath(); ctx.moveTo(cx,cy-1.2*R); ctx.lineTo(px,py); ctx.stroke();
          ctx.fillStyle='#666'; ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Monaco, monospace';
          ctx.fillText('phase e^{-i θ/2}', cx-60, cy-1.2*R-16);
          const sgn = Math.cos(ang/2) >= 0 ? '+1' : '-1';
          ctx.fillStyle='#222'; ctx.fillText('spinor sign: '+sgn+' (returns after 4π)', 16, 22);
          ctx.fillStyle='#666'; ctx.fillText('rotation θ = '+ang.toFixed(2)+' rad', 16, 40);
        }
        function setTheta(v){ ang=parseFloat(v); draw(); }
        draw();
        return { setTheta };
      }

      // 3) Higgs Mexican hat potential + masses
      function higgsSection(){
        const cv = document.getElementById('higgs'); if(!cv) return; const ctx = cv.getContext('2d');
        const W=cv.width=700, H=cv.height=380; let lambda=0.5, vev=1.0, damping=0.15;
        let state = { x: 0.2, y: 0.0, vx: 0, vy: 0 };
        const dt = 0.016;

        function V(x,y){ const r2=x*x+y*y; return 0.25*lambda*(r2 - vev*vev)*(r2 - vev*vev); }
        function gradV(x,y){ const r2=x*x+y*y; const f = 0.5*lambda*(r2 - vev*vev); return { gx: 2*f*x, gy: 2*f*y }; }

        function step(){
          const g = gradV(state.x, state.y);
          state.vx += -g.gx*dt; state.vy += -g.gy*dt;
          state.vx *= (1-damping*dt); state.vy *= (1-damping*dt);
          state.x += state.vx*dt; state.y += state.vy*dt;
        }
        function draw(){
          ctx.clearRect(0,0,W,H);
          ctx.save();
          // coordinate map
          const cx=W*0.5, cy=H*0.6, s=90;
          // potential contours
          for(let r=0.3; r<=2.2; r+=0.15){
            ctx.strokeStyle = 'rgba(0,0,0,0.07)'; ctx.beginPath(); ctx.arc(cx,cy, r*s, 0, Math.PI*2); ctx.stroke();
          }
          // vacuum circle r=vev
          ctx.strokeStyle = 'rgba(26,137,23,0.9)'; ctx.setLineDash([6,4]); ctx.beginPath(); ctx.arc(cx,cy, vev*s, 0, Math.PI*2); ctx.stroke(); ctx.setLineDash([]);
          // particle (ball)
          const px = cx + state.x*s, py = cy - state.y*s;
          ctx.fillStyle = '#222'; ctx.beginPath(); ctx.arc(px,py,6,0,Math.PI*2); ctx.fill();
          // arrows for gradient
          const g = gradV(state.x, state.y); const gx = g.gx, gy=g.gy; const ax = gx, ay=gy;
          const al = Math.hypot(ax,ay)||1; const k=24/al; ctx.strokeStyle='rgba(0,120,255,0.7)'; ctx.beginPath(); ctx.moveTo(px,py); ctx.lineTo(px+ax*k, py-ay*k); ctx.stroke();
          // text
          ctx.fillStyle = '#666'; ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Monaco, monospace';
          ctx.fillText('Mexican-hat potential contour (vacuum circle in green)', 20, 20);
          ctx.restore();
          // masses at vacuum
          const mH2 = 2*lambda*vev*vev; // radial mode mass^2
          const mA = parseFloat(document.getElementById('higgsG').value) * vev; // Abelian gauge boson: m = g v
          document.getElementById('mH').textContent = Math.sqrt(Math.max(0,mH2)).toFixed(3);
          document.getElementById('mA').textContent = mA.toFixed(3);
          const yEl = document.getElementById('yuk'); if (yEl){ const y=parseFloat(yEl.value); const mf = y*vev/Math.SQRT2; document.getElementById('mf').textContent = mf.toFixed(3);}        
        }
        let raf=0; function loop(){ step(); draw(); if(!reduce) raf=requestAnimationFrame(loop); }
        function setLambda(v){ lambda = parseFloat(v); }
        function setVev(v){ vev = parseFloat(v); }
        function reset(){ state={x:0.2,y:0.0,vx:0,vy:0}; }
        draw(); if(!reduce) loop();
        return { setLambda, setVev, reset };
      }

      // 4) U(1) gauge: local phase and covariant derivative
      function gaugeSection(){
        const cv = document.getElementById('u1'); if(!cv) return; const ctx=cv.getContext('2d');
        const W=cv.width=540, H=cv.height=260; let amp=0.8, kx=2*Math.PI/200, ky=2*Math.PI/140, g=1.0;
        function alpha(x,y){ return amp*Math.sin(kx*x)*Math.sin(ky*y); }
        function draw(){
          ctx.clearRect(0,0,W,H);
          // grid of phases
          const nx=18, ny=10; const dx=W/(nx+1), dy=H/(ny+1);
          let sumGrad=0, sumCov=0, n=0;
          for(let i=1;i<=nx;i++){
            for(let j=1;j<=ny;j++){
              const x=i*dx, y=j*dy;
              const a=alpha(x,y);
              // phase arrow
              const r=8; const ux=Math.cos(a), uy=Math.sin(a);
              ctx.strokeStyle='rgba(0,120,255,0.9)'; ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+ux*r,y-uy*r); ctx.stroke();
              // numeric gradients (central differences)
              const ax = (alpha(x+1,y)-alpha(x-1,y))/2;
              const ay = (alpha(x,y+1)-alpha(x,y-1))/2;
              const grad = Math.hypot(ax,ay);
              const cov = Math.hypot(ax+g*(-ax/g), ay+g*(-ay/g)); // with A = -(1/g) ∇α, Dψ ≈ 0 for ψ0 constant
              sumGrad+=grad; sumCov+=cov; n++;
            }
          }
          if(n>0){
            const g1=document.getElementById('gradPsi'); if(g1) g1.textContent=(sumGrad/n).toFixed(3);
            const g2=document.getElementById('covPsi'); if(g2) g2.textContent=(sumCov/n).toFixed(3);
          }
        }
        function setAmp(v){ amp=parseFloat(v); draw(); }
        draw();
        return { setAmp };
      }

      // 5) Neutrino oscillations (2-flavor accurate formula)
      function neutrinoSection(){
        const cv = document.getElementById('nu'); if(!cv) return; const ctx=cv.getContext('2d');
        const W=cv.width=700, H=cv.height=200; let theta=Math.PI/6, dm2=7.5e-5; // eV^2 (solar scale)
        let L=295, E=0.6; // km, GeV (T2K-like)

        function Pee(L,E){
          const s2 = Math.sin(2*theta); const arg = 1.267*dm2*L/E; return 1 - s2*s2*Math.sin(arg)*Math.sin(arg);
        }
        function draw(){
          ctx.clearRect(0,0,W,H);
          // probability curve vs L/E
          const maxX = 2000; // L/E axis extent
          ctx.strokeStyle='#ddd'; ctx.beginPath(); ctx.moveTo(40, H-30); ctx.lineTo(W-10, H-30); ctx.stroke();
          ctx.fillStyle='#666'; ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Monaco, monospace'; ctx.fillText('L/E (km/GeV)', W-90, H-36);
          // curve
          ctx.strokeStyle='rgba(26,137,23,0.9)'; ctx.lineWidth=1.5; ctx.beginPath();
          for(let x=0;x<=maxX;x+=5){
            const P = 1 - Math.sin(2*theta)**2 * Math.sin(1.267*dm2*x)**2;
            const X = 40 + (W-70)*x/maxX; const Y = 20 + (H-60)*(1-P);
            if(x===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
          }
          ctx.stroke();
          // marker for current L/E
          const le = L/E; const Px = 40 + (W-70)*Math.min(le,maxX)/maxX; const Py = 20 + (H-60)*(1-Pee(L,E));
          ctx.fillStyle='#222'; ctx.beginPath(); ctx.arc(Px,Py,4,0,Math.PI*2); ctx.fill();
          document.getElementById('pee').textContent = Pee(L,E).toFixed(3);
          document.getElementById('le').textContent = (L/E).toFixed(1);
        }
        function setTheta(v){ theta = parseFloat(v); draw(); }
        function setDm2(v){ dm2 = parseFloat(v); draw(); }
        function setL(v){ L = parseFloat(v); draw(); }
        function setE(v){ E = parseFloat(v); draw(); }
        draw();
        return { setTheta, setDm2, setL, setE };
      }

      // 6) Gravity: thin-lens point-mass gravitational lensing
      function lensingSection(){
        const cv = document.getElementById('lens'); if(!cv) return; const ctx=cv.getContext('2d');
        const W=cv.width=540, H=cv.height=300; let beta=0.6, thetaE=0.5;
        function solveImages(beta){
          const b=Math.abs(beta); const root=Math.sqrt(b*b+4*thetaE*thetaE); const thp=0.5*(b+root), thm=0.5*(b-root);
          const s=Math.sign(beta)||1; return [s*thm, s*thp];
        }
        function draw(){
          ctx.clearRect(0,0,W,H); const cx=W/2, cy=H/2, s=100;
          // axes
          ctx.strokeStyle='#eee'; ctx.beginPath(); ctx.moveTo(10,cy); ctx.lineTo(W-10,cy); ctx.moveTo(cx,10); ctx.lineTo(cx,H-10); ctx.stroke();
          // lens
          ctx.fillStyle='#222'; ctx.beginPath(); ctx.arc(cx,cy,4,0,Math.PI*2); ctx.fill(); ctx.fillText('lens', cx+6, cy-6);
          // Einstein radius
          ctx.strokeStyle='rgba(26,137,23,0.8)'; ctx.setLineDash([6,4]); ctx.beginPath(); ctx.arc(cx,cy,thetaE*s,0,Math.PI*2); ctx.stroke(); ctx.setLineDash([]);
          // source
          const sx=cx+beta*s, sy=cy; ctx.fillStyle='rgba(0,120,255,0.9)'; ctx.beginPath(); ctx.arc(sx,sy,4,0,Math.PI*2); ctx.fill(); ctx.fillText('source', sx+6, sy-6);
          // images
          const [thm, thp] = solveImages(beta);
          const ix1=cx+thm*s, ix2=cx+thp*s; const iy=cy;
          ctx.fillStyle='#cc3333'; ctx.beginPath(); ctx.arc(ix1,iy,4,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(ix2,iy,4,0,Math.PI*2); ctx.fill();
          ctx.fillStyle='#666'; ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Monaco, monospace';
          ctx.fillText('θ_E', cx+thetaE*s+6, cy-6);
          const bEl=document.getElementById('beta'); if(bEl) bEl.textContent = beta.toFixed(2);
          const mEl=document.getElementById('thm'); if(mEl) mEl.textContent = thm.toFixed(2);
          const pEl=document.getElementById('thp'); if(pEl) pEl.textContent = thp.toFixed(2);
        }
        function setBeta(v){ beta=parseFloat(v); draw(); }
        function setThetaE(v){ thetaE=parseFloat(v); draw(); }
        draw();
        return { setBeta, setThetaE };
      }

      // Wire up sections once DOM is ready
      function start(){
        const lorentz = lorentzSection();
        const spinor = spinorSection();
        const higgs = higgsSection();
        const u1 = gaugeSection();
        const nu = neutrinoSection();
        const lens = lensingSection();

        // UI bindings
        const vSlider = document.getElementById('vSlider'); if(vSlider) vSlider.oninput = e => lorentz.setV(e.target.value);
        const spin = document.getElementById('thetaSpin'); if(spin) spin.oninput = e => spinor.setTheta(e.target.value);
        const lam = document.getElementById('lambda'); if(lam) lam.oninput = e => higgs.setLambda(e.target.value);
        const vev = document.getElementById('vev'); if(vev) vev.oninput = e => higgs.setVev(e.target.value);
        const reset = document.getElementById('resetHiggs'); if(reset) reset.onclick = () => higgs.reset();
        const amp = document.getElementById('amp'); if(amp) amp.oninput = e => u1.setAmp(e.target.value);

        const th = document.getElementById('theta'); if(th) th.oninput = e => nu.setTheta(e.target.value);
        const dm = document.getElementById('dm2'); if(dm) dm.oninput = e => nu.setDm2(e.target.value);
        const l = document.getElementById('L'); if(l) l.oninput = e => nu.setL(e.target.value);
        const eSlider = document.getElementById('E'); if(eSlider) eSlider.oninput = e => nu.setE(e.target.value);
        const beta = document.getElementById('betaSlider'); if(beta) beta.oninput = e => lens.setBeta(e.target.value);
        const the = document.getElementById('thetaESlider'); if(the) the.oninput = e => lens.setThetaE(e.target.value);
      }
      if (document.readyState==='complete' || document.readyState==='interactive') start(); else document.addEventListener('DOMContentLoaded', start);
    })();
  </script>
</head>
<body>
  <div class="container">
    <header class="header">
      <h1 class="site-title">antifold</h1>
      <nav class="nav"><a href="../index.html">← Home</a></nav>
    </header>

    <article class="article-content">
      <div class="article-header">
        <span class="tile-category">Theory</span>
        <h1 class="article-title">First Principles Physics: Spacetime, Fields, and Symmetry</h1>
        <div class="article-meta">Interactive • Self‑contained • From fundamentals</div>
        <p class="article-description">A self‑contained, intuitive tour of the core ideas — spacetime, fields, symmetry, mass generation, mixing, and lensing — each paired with a faithful visual and equation.</p>
      </div>

      <div class="intro" style="max-width:820px; margin:0 auto 14px auto; color:var(--muted);">
        Think of physics as three ingredients: spacetime (the stage), fields (the actors), and symmetries (the rules). Each block below is a faithful, minimal visual tied to the standard formulas—no metaphor-only animations.
      </div>

      <div class="section">
        <h2>0) The toolkit (10‑second primer)</h2>
        <ul>
          <li>Vectors & tensors: components that rotate/boost between frames.</li>
          <li>Groups: symmetry move sets like $U(1),\, SU(2),\, SU(3)$.</li>
          <li>Lagrangian/action: one compact formula; least action yields equations of motion.</li>
        </ul>
      </div>

      <div class="section">
        <h2>1) The stage: spacetime and the Lorentz group</h2>
        <p class="note">What it is: spacetime is a 4D arena with invariant interval $s^2 = t^2 - x^2 - y^2 - z^2$ (we use $c=1$ and plot 1+1D). Why it’s used: the same laws must hold for any inertial observer. Those changes of frame are Lorentz transformations that keep light cones and $s^2$ fixed.</p>
        <p class="note">Equations: a boost along $x$ mixes $x$ and $t$ via $x' = \gamma(x-vt)$ and $t' = \gamma(t-vx)$ with $\gamma = 1/\sqrt{1-v^2}$. The blue lines show the $x'$ and $t'$ axes of the moving frame; hyperbolas depict $t^2-x^2=\text{const}$.</p>
        <div class="demo">
          <canvas id="lorentz" class="demo-canvas" width="700" height="380"></canvas>
          <div class="controls">
            <label>Velocity v/c <input id="vSlider" type="range" min="-0.95" max="0.95" step="0.01" value="0.60"/></label>
          </div>
          <div class="kpis">
            <div class="kpi"><b>v</b><div class="val" id="lorentzV">0.60 c</div></div>
            <div class="kpi"><b>gamma</b><div class="val" id="lorentzGamma">1.250</div></div>
          </div>
        </div>
      </div>

      <div class="section">
        <h2>2) Actors: spinors live in the double cover</h2>
        <p class="note">What it is: spin is intrinsic angular momentum. Spin-$\tfrac12$ matter (electrons, quarks) is described by two‑component spinors. Why used: their transformation law captures how these particles respond to rotations and magnetic fields.</p>
        <p class="note">Equation: a rotation about $z$ acts as $R_z(\theta)=\exp\!\big(-\tfrac{i}{2}\,\theta\,\sigma_z\big)$. Consequence: a $2\pi$ rotation multiplies the spinor by $-1$ (probabilities unchanged), and only after $4\pi$ does the state return exactly. The blue pointer shows physical orientation (SO(3), period $2\pi$); the green hand shows spinor phase (SU(2), period $4\pi$).</p>
        <div class="demo">
          <canvas id="spinor" class="demo-canvas" width="540" height="260"></canvas>
          <div class="controls"><label>Rotation $\theta$ <input id="thetaSpin" type="range" min="0" max="6.283" step="0.01" value="0"/></label></div>
        </div>
      </div>

      <div class="section">
        <h2>3) Rulebook: gauge principle (U(1))</h2>
        <p class="note">What it is: physics shouldn’t depend on how we label a field’s internal phase. Why used: demanding invariance under local rephasings $\psi(x)\to e^{i\alpha(x)}\psi(x)$ forces the introduction of a gauge field $A_\mu$ and the covariant derivative $D_\mu=\partial_\mu+i g A_\mu$ so that $D_\mu\psi$ transforms like $\psi$.</p>
        <p class="note">Equations: the gauge field’s curvature is $F_{\mu\nu}=\partial_\mu A_\nu-\partial_\nu A_\mu$ (plus commutator for non‑Abelian cases). A minimal Lagrangian is $\mathcal L=-\tfrac14 F^a_{\mu\nu}F^{a\,\mu\nu}+ i\bar\psi\gamma^\mu D_\mu\psi$. The demo shows that picking $A_\mu=-(1/g)\,\partial_\mu\alpha$ cancels the spurious gradient from a pure phase, making $D\psi\approx 0$ when $|\psi|$ is uniform.</p>
        <div class="demo">
          <canvas id="u1" class="demo-canvas" width="540" height="260"></canvas>
          <div class="controls"><label>Phase amplitude <input id="amp" type="range" min="0" max="1.5" step="0.01" value="0.8"/></label></div>
          <div class="kpis">
            <div class="kpi"><b>||∇ψ|| (naive)</b><div class="val" id="gradPsi">—</div></div>
            <div class="kpi"><b>||Dψ|| (with Aμ)</b><div class="val" id="covPsi">—</div></div>
          </div>
        </div>
      </div>

      <div class="section">
        <h2>4) Mass from a vacuum: Higgs and Yukawa</h2>
        <p class="note">What it is: a scalar field with a symmetric “Mexican‑hat” potential chooses a nonzero magnitude everywhere (spontaneous symmetry breaking). Why used: gauge symmetry forbids naive mass terms; interacting with a field that has a vacuum value generates masses without breaking local symmetry.</p>
        <p class="note">Equations: $\mathcal L_\phi=|D_\mu\phi|^2-\tfrac{\lambda}{4}(|\phi|^2-v^2)^2$. Small oscillations give a radial mass $m_H^2=2\lambda v^2$; the angular (phase) mode is eaten, giving the gauge boson mass $m_A=g v$ (Abelian case). Fermions get $m_f= y v/\sqrt{2}$ from the Yukawa $\mathcal L_Y=-y\,\bar\psi\phi\psi$.</p>
        <div class="demo">
          <canvas id="higgs" class="demo-canvas" width="700" height="380"></canvas>
          <div class="controls">
            <label>λ <input id="lambda" type="range" min="0.1" max="1.5" step="0.05" value="0.50"/></label>
            <label>v (VEV) <input id="vev" type="range" min="0.5" max="2.0" step="0.05" value="1.00"/></label>
            <label>g <input id="higgsG" type="range" min="0.0" max="1.5" step="0.05" value="0.65"/></label>
            <label>y (Yukawa) <input id="yuk" type="range" min="0.0" max="2.0" step="0.01" value="1.00"/></label>
            <button id="resetHiggs" class="btn">Reset</button>
          </div>
          <div class="kpis">
            <div class="kpi"><b>Higgs mass</b><div class="val" id="mH">—</div></div>
            <div class="kpi"><b>Gauge mass</b><div class="val" id="mA">—</div></div>
            <div class="kpi"><b>Fermion mass</b><div class="val" id="mf">—</div></div>
          </div>
        </div>
      </div>

      <div class="section">
        <h2>5) Flavor mixing: neutrino oscillations</h2>
        <p class="note">What it is: interaction (flavor) states are superpositions of mass states. Why used: different masses accumulate different quantum phases in flight, so the flavor content oscillates with distance/energy.</p>
        <p class="note">Equations (2‑flavor): $\lvert \nu_e\rangle=\cos\theta\,\lvert \nu_1\rangle+\sin\theta\,\lvert \nu_2\rangle$. The phase difference grows like $\Delta\phi\sim \Delta m^2 L/(2E)$, giving $P_{ee}=1-\sin^2(2\theta)\,\sin^2\!\big(1.267\,\Delta m^2 L/E\big)$ with $\Delta m^2$ in eV$^2$, $L$ in km, and $E$ in GeV.</p>
        <div class="demo">
          <canvas id="nu" class="demo-canvas" width="700" height="200"></canvas>
          <div class="controls">
            <label>θ <input id="theta" type="range" min="0.0" max="1.57" step="0.01" value="0.52"/></label>
            <label>Δm² (eV²) <input id="dm2" type="range" min="1e-5" max="3e-3" step="1e-5" value="7.5e-5"/></label>
            <label>L (km) <input id="L" type="range" min="1" max="1300" step="1" value="295"/></label>
            <label>E (GeV) <input id="E" type="range" min="0.2" max="10" step="0.05" value="0.6"/></label>
          </div>
          <div class="kpis">
            <div class="kpi"><b>P(νe→νe)</b><div class="val" id="pee">—</div></div>
            <div class="kpi"><b>L/E</b><div class="val" id="le">—</div></div>
          </div>
        </div>
      </div>

      <div class="section">
        <h2>6) Gravity’s piece: thin‑lens intuition</h2>
        <p class="note">What it is: light follows geodesics in curved spacetime. In the weak‑field, small‑angle limit, a foreground mass deflects light like a thin optical lens. Why used: it predicts multiple images and arcs seen in astrophysics and requires only simple geometry.</p>
        <p class="note">Equations: deflection $\alpha=\tfrac{4GM}{c^2 b}$. In the thin‑lens equation (angles), the Einstein radius sets the scale, and for an on‑axis point source the image positions are $\theta_{\pm}=\tfrac12\big(\beta\pm\sqrt{\beta^2+4\theta_E^2}\big)$. The demo rescales units so $\theta_E$ is the green circle.</p>
        <div class="demo">
          <canvas id="lens" class="demo-canvas" width="540" height="300"></canvas>
          <div class="controls">
            <label>Source angle $\beta/\theta_E$ <input id="betaSlider" type="range" min="-1.5" max="1.5" step="0.01" value="0.6"/></label>
            <label>$\theta_E$ (scale) <input id="thetaESlider" type="range" min="0.2" max="0.8" step="0.01" value="0.5"/></label>
          </div>
          <div class="kpis">
            <div class="kpi"><b>β</b><div class="val" id="beta">—</div></div>
            <div class="kpi"><b>θ−</b><div class="val" id="thm">—</div></div>
            <div class="kpi"><b>θ+</b><div class="val" id="thp">—</div></div>
          </div>
        </div>
      </div>

      <div class="section">
        <h2>7) Putting the pieces together</h2>
        <ul>
          <li>Spacetime: Einstein–Hilbert term $\int \!\sqrt{-g}\,R$ (curved stage).</li>
          <li>Forces: Yang–Mills $-\tfrac14 F^a_{\mu\nu}F^{a\,\mu\nu}$ for $SU(3)\times SU(2)\times U(1)$.</li>
          <li>Matter: Dirac $i\bar\psi\gamma^\mu D_\mu\psi$; covariant $D_\mu$ couples fields to forces.</li>
          <li>Mass: Higgs potential + Yukawas turn the VEV into particle masses.</li>
          <li>Mixing: CKM/PMNS matrices rotate between mass and weak bases.</li>
        </ul>
      </div>

      <div class="section">
        <h2>8) Intuition snapshots</h2>
        <ul>
          <li>Symmetry → force: local relabeling requires a gauge connection.</li>
          <li>Geometry → gravity: letting lengths depend on position gives curvature.</li>
          <li>Vacuum isn’t empty: a field’s VEV reshapes what “massless” means.</li>
          <li>Mixing is misalignment: flavor oscillations are basis rotations in flight.</li>
        </ul>
      </div>
    </article>

    <footer class="footer">
      <p>&copy; 2024 antifold • Essays and simulations</p>
    </footer>
  </div>
</body>
</html>
