<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>{{ page.title | default: site.title }}</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="{{ '/assets/css/main.css' | relative_url }}">
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true
      }
    });
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

<script>
// Jekyll posts data (dynamically rendered)
const POSTS_DATA = [
  {% for post in site.posts %}
  {
    title: {{ post.title | jsonify }},
    description: {{ post.description | default: post.excerpt | strip_html | truncate: 120 | jsonify }},
    url: {% if post.external_link %}"{{ post.external_link }}"{% else %}"{{ post.url | relative_url }}"{% endif %},
    date: "{{ post.date | date: '%B %Y' }}",
    categories: {{ post.categories | jsonify }},
    external: {% if post.external_link %}true{% else %}false{% endif %}
  }{% unless forloop.last %},{% endunless %}
  {% endfor %}
];
</script>

</head>
<body>
  <div class="site-header">
    <div class="site-title">{{ site.title }}</div>
    <div class="github-info">
      <a href="https://github.com/{{ site.github_username }}" target="_blank" rel="noopener">
        @{{ site.github_username }}
      </a>
    </div>
  </div>
  
  <div id="ant-world"></div>
  
  <div class="control-panel" id="control-panel">
    <button class="panel-toggle" id="panel-toggle">⚙️</button>
    <div class="panel-content" id="panel-content">
      <h3>Colony Controls</h3>
      <div class="control-row">
        <label>Food Strength</label>
        <input type="range" id="food-strength" min="0.1" max="2.0" step="0.1" value="1.0">
        <span class="value">1.0</span>
      </div>
      <div class="control-row">
        <label>Breeding Rate</label>
        <input type="range" id="breeding-rate" min="0" max="0.02" step="0.001" value="0.005">
        <span class="value">0.5%</span>
      </div>
      <div class="control-row">
        <label>Collaboration</label>
        <select id="collaboration-mode">
          <option value="independent">Independent</option>
          <option value="flocking">Flocking</option>
          <option value="swarm">Swarm Intelligence</option>
        </select>
      </div>
      <div class="control-row">
        <label>Ant Speed</label>
        <input type="range" id="ant-speed" min="0.1" max="2.0" step="0.1" value="0.8">
        <span class="value">0.8</span>
      </div>
      <div class="control-row">
        <label>Food Decay</label>
        <input type="range" id="food-decay" min="0.95" max="0.999" step="0.001" value="0.98">
        <span class="value">98%</span>
      </div>
      <div class="control-buttons">
        <button id="clear-food">Clear Food</button>
        <button id="reset-ants">Reset Colony</button>
      </div>
    </div>
  </div>

  <div class="articles-grid" id="articles-grid">
    <!-- Articles will be inserted here by JavaScript -->
  </div>
  
  <main class="crazy-container">
    {{ content }}
  </main>
  
  <footer>
    <div class="container">
      <p>&copy; {{ site.time | date: '%Y' }} {{ site.title }}. All rights reserved.</p>
    </div>
  </footer>

<script>
class AntColony {
  constructor() {
    this.antContainer = document.getElementById('ant-world');
    this.articlesContainer = document.getElementById('articles-grid');
    this.ants = [];
    this.articles = [];
    this.freeAnts = [];
    this.foodPoints = [];
    this.width = window.innerWidth;
    this.height = window.innerHeight;
    this.params = {
      foodStrength: 1.0,
      breedingRate: 0.005,
      collaborationMode: 'flocking',
      antSpeed: 0.8,
      foodDecay: 0.995,
      maxDensity: 8,
      dispersalForce: 0.3
    };
    
    // Performance optimizations
    this.frameCount = 0;
    this.spatialGrid = null;
    this.gridSize = 50;
    this.lastUpdate = 0;
    this.targetFPS = 60;
    this.frameInterval = 1000 / this.targetFPS;
    
    this.init();
  }

  init() {
    // Create articles in the flex grid
    POSTS_DATA.forEach((post, index) => {
      this.createArticle(post, index);
    });

    // Wait for articles to be positioned, then create ants
    setTimeout(() => {
      this.updateArticlePositions();
      this.articles.forEach(article => {
        this.createAntGroup(article);
      });
      this.createFreeAnts(80 + POSTS_DATA.length * 12);
    }, 100);

    // Add click handler for food placement
    this.antContainer.addEventListener('click', (e) => {
      this.addFood(e.clientX, e.clientY);
    });

    // Initialize control panel
    this.initControls();

    // Start optimized animation loop
    requestAnimationFrame((time) => this.animate(time));

    // Handle resize
    window.addEventListener('resize', () => {
      this.width = window.innerWidth;
      this.height = window.innerHeight;
      setTimeout(() => this.updateArticlePositions(), 100);
    });
  }

  updateArticlePositions() {
    this.articles.forEach(article => {
      const rect = article.element.getBoundingClientRect();
      article.x = rect.left + rect.width / 2;
      article.y = rect.top + rect.height / 2;
    });
  }

  buildSpatialGrid() {
    // Create spatial grid for efficient neighbor queries
    const cols = Math.ceil(this.width / this.gridSize);
    const rows = Math.ceil(this.height / this.gridSize);
    this.spatialGrid = Array(cols * rows).fill(null).map(() => []);
    
    // Place all ants in grid cells
    [...this.ants, ...this.freeAnts].forEach(ant => {
      const col = Math.floor(ant.x / this.gridSize);
      const row = Math.floor(ant.y / this.gridSize);
      const index = col + row * cols;
      if (index >= 0 && index < this.spatialGrid.length) {
        this.spatialGrid[index].push(ant);
      }
    });
  }

  getNearbyAnts(ant, radius) {
    const col = Math.floor(ant.x / this.gridSize);
    const row = Math.floor(ant.y / this.gridSize);
    const cols = Math.ceil(this.width / this.gridSize);
    const cellRadius = Math.ceil(radius / this.gridSize);
    
    const nearby = [];
    
    for (let dy = -cellRadius; dy <= cellRadius; dy++) {
      for (let dx = -cellRadius; dx <= cellRadius; dx++) {
        const checkCol = col + dx;
        const checkRow = row + dy;
        const index = checkCol + checkRow * cols;
        
        if (index >= 0 && index < this.spatialGrid.length && 
            checkCol >= 0 && checkCol < cols) {
          this.spatialGrid[index].forEach(other => {
            if (other !== ant) {
              const dist = Math.sqrt((other.x - ant.x) ** 2 + (other.y - ant.y) ** 2);
              if (dist < radius) {
                nearby.push({ ant: other, distance: dist });
              }
            }
          });
        }
      }
    }
    
    return nearby;
  }

  createArticle(post, index) {
    const article = document.createElement('div');
    article.className = `article-carried ${post.categories[0] || 'general'}`;
    
    const categoryLabel = this.getCategoryLabel(post.categories[0]);
    
    article.innerHTML = `
      <h3>${post.title}</h3>
      <p>${post.description}</p>
      <div class="meta">
        <span class="category">${categoryLabel}</span>
        <span class="date">${post.date}</span>
      </div>
    `;

    // Add click handler with ant response
    article.addEventListener('click', (e) => {
      e.stopPropagation();
      
      // Get current article position
      const rect = article.getBoundingClientRect();
      const articleX = rect.left + rect.width / 2;
      const articleY = rect.top + rect.height / 2;
      
      // Animate ants away from article briefly
      this.ants.filter(ant => ant.article && ant.article.post === post)
        .forEach(ant => {
          const awayAngle = Math.random() * Math.PI * 2;
          ant.target = {
            x: articleX + Math.cos(awayAngle) * 50,
            y: articleY + Math.sin(awayAngle) * 50
          };
          ant.targetTime = Date.now() + 800;
        });
      
      // Navigate after brief delay
      setTimeout(() => {
        if (post.external) {
          window.open(post.url, '_blank');
        } else {
          window.location.href = post.url;
        }
      }, 300);
    });

    // Add to flex grid instead of absolute positioning
    this.articlesContainer.appendChild(article);
    
    this.articles.push({
      element: article,
      x: 0, // Will be updated after positioning
      y: 0,
      post: post
    });
  }

  createAntGroup(article) {
    // Create 8-12 ants per article for better visibility
    const numAnts = 8 + Math.floor(Math.random() * 5);
    const ants = [];
    
    for (let i = 0; i < numAnts; i++) {
      const ant = document.createElement('div');
      ant.className = 'ant';
      this.antContainer.appendChild(ant);
      
      const angle = (i / numAnts) * Math.PI * 2;
      const radius = 30 + Math.random() * 20;
      
      ants.push({
        element: ant,
        x: article.x + 150 + Math.cos(angle) * radius,
        y: article.y + 75 + Math.sin(angle) * radius,
        angle: Math.random() * Math.PI * 2,
        speed: 0.3 + Math.random() * 0.5,
        targetAngle: angle,
        orbitRadius: radius,
        article: article
      });
    }
    
    this.ants.push(...ants);
  }

  createFreeAnts(count) {
    for (let i = 0; i < count; i++) {
      const ant = document.createElement('div');
      ant.className = 'ant';
      this.antContainer.appendChild(ant);
      
      this.freeAnts.push({
        element: ant,
        x: Math.random() * this.width,
        y: Math.random() * this.height,
        angle: Math.random() * Math.PI * 2,
        speed: 0.2 + Math.random() * 0.4,
        wanderAngle: Math.random() * Math.PI * 2,
        target: null
      });
    }
  }

  addFood(x, y) {
    const clickRadius = 30;
    
    // Check if clicking near existing food to accumulate
    let existingFood = this.foodPoints.find(food => {
      const dx = food.x - x;
      const dy = food.y - y;
      return Math.sqrt(dx * dx + dy * dy) < clickRadius;
    });

    if (existingFood) {
      // Accumulate food at existing point
      existingFood.strength = Math.min(existingFood.strength + this.params.foodStrength * 0.5, 3.0);
      existingFood.radius = Math.min(20 + existingFood.strength * 30, 100);
      
      // Update visual size
      const scale = 0.5 + existingFood.strength * 0.3;
      existingFood.element.style.transform = `scale(${scale})`;
    } else {
      // Create new food point
      const food = document.createElement('div');
      food.className = 'food-point';
      food.style.left = (x - 3) + 'px';
      food.style.top = (y - 3) + 'px';
      this.antContainer.appendChild(food);

      const foodPoint = {
        element: food,
        x: x,
        y: y,
        strength: this.params.foodStrength,
        radius: 50,
        id: Date.now() + Math.random()
      };

      this.foodPoints.push(foodPoint);
    }

    // Attract nearby ants to the food
    [...this.ants, ...this.freeAnts].forEach(ant => {
      const dx = x - ant.x;
      const dy = y - ant.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance < 150) {
        ant.target = { 
          x: x + (Math.random() - 0.5) * 40, 
          y: y + (Math.random() - 0.5) * 40 
        };
        ant.targetTime = Date.now() + 2000 + Math.random() * 3000;
      }
    });
  }

  initControls() {
    const toggle = document.getElementById('panel-toggle');
    const content = document.getElementById('panel-content');
    
    toggle.addEventListener('click', () => {
      content.classList.toggle('open');
    });

    // Bind control inputs
    this.bindControl('food-strength', 'foodStrength', (v) => v.toFixed(1));
    this.bindControl('breeding-rate', 'breedingRate', (v) => (v * 100).toFixed(1) + '%');
    this.bindControl('ant-speed', 'antSpeed', (v) => v.toFixed(1));
    this.bindControl('food-decay', 'foodDecay', (v) => (v * 100).toFixed(1) + '%');

    document.getElementById('collaboration-mode').addEventListener('change', (e) => {
      this.params.collaborationMode = e.target.value;
    });

    document.getElementById('clear-food').addEventListener('click', () => {
      this.clearFood();
    });

    document.getElementById('reset-ants').addEventListener('click', () => {
      this.resetColony();
    });
  }

  bindControl(id, param, formatter) {
    const input = document.getElementById(id);
    const valueSpan = input.nextElementSibling;
    
    input.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      this.params[param] = value;
      valueSpan.textContent = formatter(value);
    });
  }

  clearFood() {
    this.foodPoints.forEach(food => {
      food.element.remove();
    });
    this.foodPoints = [];
  }

  resetColony() {
    // Remove all ants
    [...this.ants, ...this.freeAnts].forEach(ant => {
      ant.element.remove();
    });
    this.ants = [];
    this.freeAnts = [];
    
    // Recreate colony
    setTimeout(() => {
      this.articles.forEach(article => {
        this.createAntGroup(article);
      });
      this.createFreeAnts(80 + POSTS_DATA.length * 12);
    }, 100);
  }

  getCategoryLabel(category) {
    const labels = {
      'research': 'Research Paper',
      'project': 'Open Source',
      'blog': 'Blog Post',
      'software': 'Software Project',
      'paper': 'Research Paper'
    };
    return labels[category] || 'Article';
  }

  moveAnt(ant) {
    const now = Date.now();
    
    // Density-based behavior (population control)
    const densityResult = this.checkDensity(ant);
    
    if (densityResult.shouldDie) {
      this.killAnt(ant);
      return;
    }
    
    if (densityResult.shouldDisperse) {
      // Force ant to move away from crowded area
      ant.angle = densityResult.dispersalAngle;
      ant.speed = 1.0 * this.params.antSpeed;
      ant.target = null; // Override other targets
    } else {
      // Normal behavior when not overcrowded
      
      // Food seeking behavior
      let nearestFood = null;
      let nearestFoodDistance = Infinity;
      
      this.foodPoints.forEach(food => {
        const dx = food.x - ant.x;
        const dy = food.y - ant.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < food.radius && distance < nearestFoodDistance) {
          nearestFood = food;
          nearestFoodDistance = distance;
        }
      });
      
      // Prioritize food over other targets
      if (nearestFood && nearestFoodDistance < nearestFood.radius) {
        const attraction = nearestFood.strength * (1 - nearestFoodDistance / nearestFood.radius);
        const dx = nearestFood.x - ant.x;
        const dy = nearestFood.y - ant.y;
        const angleToFood = Math.atan2(dy, dx);
        ant.angle = this.lerp(ant.angle, angleToFood, 0.1 + attraction * 0.1);
        ant.speed = (0.5 + attraction) * this.params.antSpeed;
      } else if (ant.target && now < ant.targetTime) {
        // Move towards click target
        const dx = ant.target.x - ant.x;
        const dy = ant.target.y - ant.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 5) {
          const angleToTarget = Math.atan2(dy, dx);
          ant.angle = this.lerp(ant.angle, angleToTarget, 0.15);
          ant.speed = Math.min(ant.speed * 1.1, 1.5) * this.params.antSpeed;
        } else {
          ant.target = null;
        }
      } else {
        ant.target = null;
        ant.speed = Math.max(ant.speed * 0.95, 0.3) * this.params.antSpeed;
        
        // Collaboration behaviors
        if (this.params.collaborationMode === 'flocking') {
          this.applyFlockingBehavior(ant);
        } else if (this.params.collaborationMode === 'swarm') {
          this.applySwarmBehavior(ant);
        }
        
        if (ant.article) {
          // Orbit around article
          const article = ant.article;
          const centerX = article.x;
          const centerY = article.y;
          
          ant.targetAngle += 0.008 + Math.random() * 0.015;
          const targetX = centerX + Math.cos(ant.targetAngle) * ant.orbitRadius;
          const targetY = centerY + Math.sin(ant.targetAngle) * ant.orbitRadius;
          
          const dx = targetX - ant.x;
          const dy = targetY - ant.y;
          const angleToOrbit = Math.atan2(dy, dx);
          ant.angle = this.lerp(ant.angle, angleToOrbit, 0.08);
        } else {
          // Wander randomly
          ant.wanderAngle += (Math.random() - 0.5) * 0.25;
          ant.angle = this.lerp(ant.angle, ant.wanderAngle, 0.04);
        }
      }
    }
    
    // Move ant
    ant.x += Math.cos(ant.angle) * ant.speed;
    ant.y += Math.sin(ant.angle) * ant.speed;
    
    // Screen wrapping
    if (ant.x < -10) ant.x = this.width + 10;
    if (ant.x > this.width + 10) ant.x = -10;
    if (ant.y < -10) ant.y = this.height + 10;
    if (ant.y > this.height + 10) ant.y = -10;
    
    // Update visual
    ant.element.style.left = ant.x + 'px';
    ant.element.style.top = ant.y + 'px';
    ant.element.style.transform = `rotate(${ant.angle}rad)`;
    
    // Breeding check (only if not overcrowded)
    if (!densityResult.shouldDisperse) {
      this.checkBreeding(ant);
    }
  }

  checkDensity(ant) {
    const nearby = this.getNearbyAnts(ant, 25);
    const nearbyCount = nearby.length;
    
    if (nearbyCount > this.params.maxDensity) {
      // Overcrowded - chance to die or forced dispersal
      if (nearbyCount > this.params.maxDensity * 1.5 && Math.random() < 0.015) {
        return { shouldDie: true };
      }
      
      // Calculate dispersal direction (away from crowd center)
      if (nearby.length > 0) {
        let avgX = 0, avgY = 0;
        nearby.forEach(neighbor => {
          avgX += neighbor.ant.x;
          avgY += neighbor.ant.y;
        });
        avgX /= nearby.length;
        avgY /= nearby.length;
        
        const awayAngle = Math.atan2(ant.y - avgY, ant.x - avgX);
        return { 
          shouldDisperse: true, 
          dispersalAngle: awayAngle + (Math.random() - 0.5) * 0.4
        };
      }
    }
    
    return { shouldDie: false, shouldDisperse: false };
  }

  killAnt(ant) {
    // Remove ant from arrays and DOM
    const antIndex = this.ants.indexOf(ant);
    if (antIndex > -1) {
      this.ants.splice(antIndex, 1);
    } else {
      const freeIndex = this.freeAnts.indexOf(ant);
      if (freeIndex > -1) {
        this.freeAnts.splice(freeIndex, 1);
      }
    }
    
    ant.element.remove();
  }

  applyFlockingBehavior(ant) {
    const nearby = this.getNearbyAnts(ant, 40);
    
    if (nearby.length > 0) {
      let avgAngle = 0;
      nearby.forEach(neighbor => {
        avgAngle += neighbor.ant.angle;
      });
      avgAngle /= nearby.length;
      ant.angle = this.lerp(ant.angle, avgAngle, 0.08);
    }
  }

  applySwarmBehavior(ant) {
    const nearby = this.getNearbyAnts(ant, 60);
    
    if (nearby.length > 2) {
      let centerX = 0, centerY = 0;
      nearby.forEach(neighbor => {
        centerX += neighbor.ant.x;
        centerY += neighbor.ant.y;
      });
      centerX /= nearby.length;
      centerY /= nearby.length;
      
      const dx = centerX - ant.x;
      const dy = centerY - ant.y;
      const angleToCenter = Math.atan2(dy, dx);
      ant.angle = this.lerp(ant.angle, angleToCenter, 0.06);
    }
  }

  checkBreeding(ant) {
    if (Math.random() > this.params.breedingRate) return;
    
    // Find nearby ants for breeding using spatial grid
    const nearby = this.getNearbyAnts(ant, 15);
    
    if (nearby.length > 0 && nearby.length < this.params.maxDensity / 2) {
      // Only breed if not approaching overcrowding
      this.spawnNewAnt(ant.x, ant.y);
    }
  }

  spawnNewAnt(x, y) {
    const ant = document.createElement('div');
    ant.className = 'ant';
    this.antContainer.appendChild(ant);
    
    const newAnt = {
      element: ant,
      x: x + (Math.random() - 0.5) * 20,
      y: y + (Math.random() - 0.5) * 20,
      angle: Math.random() * Math.PI * 2,
      speed: 0.2 + Math.random() * 0.4,
      wanderAngle: Math.random() * Math.PI * 2,
      target: null,
      article: null
    };
    
    this.freeAnts.push(newAnt);
  }


  lerp(a, b, t) {
    // Handle angle wrapping
    let diff = b - a;
    if (diff > Math.PI) diff -= Math.PI * 2;
    if (diff < -Math.PI) diff += Math.PI * 2;
    return a + diff * t;
  }

  animate(currentTime) {
    // Frame rate limiting
    if (currentTime - this.lastUpdate < this.frameInterval) {
      requestAnimationFrame((time) => this.animate(time));
      return;
    }
    this.lastUpdate = currentTime;
    this.frameCount++;
    
    // Build spatial grid for efficient neighbor queries (every 3 frames)
    if (this.frameCount % 3 === 0) {
      this.buildSpatialGrid();
    }
    
    // Update food points (every frame but optimized)
    if (this.frameCount % 2 === 0) {
      this.foodPoints = this.foodPoints.filter(food => {
        food.strength *= this.params.foodDecay;
        
        if (food.strength < 0.1) {
          food.element.remove();
          return false;
        }
        
        // Visual feedback for food strength (less frequent updates)
        const opacity = Math.min(1, food.strength);
        const scale = 0.5 + food.strength * 0.5;
        food.element.style.opacity = opacity;
        food.element.style.transform = `scale(${scale})`;
        
        return true;
      });
    }
    
    // Update article positions less frequently
    if (this.frameCount % 30 === 0) {
      this.updateArticlePositions();
    }
    
    // Move ants (split processing across frames for large populations)
    const allAnts = [...this.ants, ...this.freeAnts];
    const batchSize = Math.max(10, Math.ceil(allAnts.length / 3));
    const startIndex = (this.frameCount * batchSize) % allAnts.length;
    
    for (let i = 0; i < batchSize && i < allAnts.length; i++) {
      const index = (startIndex + i) % allAnts.length;
      const ant = allAnts[index];
      if (ant) {
        this.moveAnt(ant);
      }
    }
    
    // Continue animation
    requestAnimationFrame((time) => this.animate(time));
  }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  new AntColony();
});
</script>

</body>
</html> 