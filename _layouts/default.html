<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>{{ page.title | default: site.title }}</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="{{ '/assets/css/main.css' | relative_url }}">
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true
      }
    });
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

<script>
// Jekyll posts data (dynamically rendered)
const POSTS_DATA = [
  {% for post in site.posts %}
  {
    title: {{ post.title | jsonify }},
    description: {{ post.description | default: post.excerpt | strip_html | truncate: 120 | jsonify }},
    url: {% if post.external_link %}"{{ post.external_link }}"{% else %}"{{ post.url | relative_url }}"{% endif %},
    date: "{{ post.date | date: '%B %Y' }}",
    categories: {{ post.categories | jsonify }},
    external: {% if post.external_link %}true{% else %}false{% endif %}
  }{% unless forloop.last %},{% endunless %}
  {% endfor %}
];
</script>

</head>
<body>
  <div class="site-header">
    <div class="site-title">{{ site.title }}</div>
    <div class="github-info">
      <a href="https://github.com/{{ site.github_username }}" target="_blank" rel="noopener">
        @{{ site.github_username }}
      </a>
    </div>
  </div>
  
  <div id="ant-world"></div>
  
  <div class="articles-grid" id="articles-grid">
    <!-- Articles will be inserted here by JavaScript -->
  </div>
  
  <main class="crazy-container">
    {{ content }}
  </main>
  
  <footer>
    <div class="container">
      <p>&copy; {{ site.time | date: '%Y' }} {{ site.title }}. All rights reserved.</p>
    </div>
  </footer>

<script>
class AntColony {
  constructor() {
    this.antContainer = document.getElementById('ant-world');
    this.articlesContainer = document.getElementById('articles-grid');
    this.ants = [];
    this.articles = [];
    this.freeAnts = [];
    this.width = window.innerWidth;
    this.height = window.innerHeight;
    this.clickedPoints = [];
    this.init();
  }

  init() {
    // Create articles in the flex grid
    POSTS_DATA.forEach((post, index) => {
      this.createArticle(post, index);
    });

    // Wait for articles to be positioned, then create ants
    setTimeout(() => {
      this.updateArticlePositions();
      this.articles.forEach(article => {
        this.createAntGroup(article);
      });
      this.createFreeAnts(80 + POSTS_DATA.length * 12);
    }, 100);

    // Add click handler for spawning ants
    this.antContainer.addEventListener('click', (e) => {
      this.handleClick(e.clientX, e.clientY);
    });

    // Start animation
    this.animate();

    // Handle resize
    window.addEventListener('resize', () => {
      this.width = window.innerWidth;
      this.height = window.innerHeight;
      setTimeout(() => this.updateArticlePositions(), 100);
    });
  }

  updateArticlePositions() {
    this.articles.forEach(article => {
      const rect = article.element.getBoundingClientRect();
      article.x = rect.left + rect.width / 2;
      article.y = rect.top + rect.height / 2;
    });
  }

  createArticle(post, index) {
    const article = document.createElement('div');
    article.className = `article-carried ${post.categories[0] || 'general'}`;
    
    const categoryLabel = this.getCategoryLabel(post.categories[0]);
    
    article.innerHTML = `
      <h3>${post.title}</h3>
      <p>${post.description}</p>
      <div class="meta">
        <span class="category">${categoryLabel}</span>
        <span class="date">${post.date}</span>
      </div>
    `;

    // Add click handler with ant response
    article.addEventListener('click', (e) => {
      e.stopPropagation();
      
      // Get current article position
      const rect = article.getBoundingClientRect();
      const articleX = rect.left + rect.width / 2;
      const articleY = rect.top + rect.height / 2;
      
      // Animate ants away from article briefly
      this.ants.filter(ant => ant.article && ant.article.post === post)
        .forEach(ant => {
          const awayAngle = Math.random() * Math.PI * 2;
          ant.target = {
            x: articleX + Math.cos(awayAngle) * 50,
            y: articleY + Math.sin(awayAngle) * 50
          };
          ant.targetTime = Date.now() + 800;
        });
      
      // Navigate after brief delay
      setTimeout(() => {
        if (post.external) {
          window.open(post.url, '_blank');
        } else {
          window.location.href = post.url;
        }
      }, 300);
    });

    // Add to flex grid instead of absolute positioning
    this.articlesContainer.appendChild(article);
    
    this.articles.push({
      element: article,
      x: 0, // Will be updated after positioning
      y: 0,
      post: post
    });
  }

  createAntGroup(article) {
    // Create 8-12 ants per article for better visibility
    const numAnts = 8 + Math.floor(Math.random() * 5);
    const ants = [];
    
    for (let i = 0; i < numAnts; i++) {
      const ant = document.createElement('div');
      ant.className = 'ant';
      this.antContainer.appendChild(ant);
      
      const angle = (i / numAnts) * Math.PI * 2;
      const radius = 30 + Math.random() * 20;
      
      ants.push({
        element: ant,
        x: article.x + 150 + Math.cos(angle) * radius,
        y: article.y + 75 + Math.sin(angle) * radius,
        angle: Math.random() * Math.PI * 2,
        speed: 0.3 + Math.random() * 0.5,
        targetAngle: angle,
        orbitRadius: radius,
        article: article
      });
    }
    
    this.ants.push(...ants);
  }

  createFreeAnts(count) {
    for (let i = 0; i < count; i++) {
      const ant = document.createElement('div');
      ant.className = 'ant';
      this.antContainer.appendChild(ant);
      
      this.freeAnts.push({
        element: ant,
        x: Math.random() * this.width,
        y: Math.random() * this.height,
        angle: Math.random() * Math.PI * 2,
        speed: 0.2 + Math.random() * 0.4,
        wanderAngle: Math.random() * Math.PI * 2,
        target: null
      });
    }
  }

  handleClick(clickX, clickY) {
    // Add click point that attracts nearby ants
    this.clickedPoints.push({
      x: clickX,
      y: clickY,
      strength: 1.0,
      decay: 0.98,
      radius: 80
    });

    // Attract nearby ants to the click
    [...this.ants, ...this.freeAnts].forEach(ant => {
      const dx = clickX - ant.x;
      const dy = clickY - ant.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance < 150) {
        ant.target = { x: clickX + (Math.random() - 0.5) * 40, y: clickY + (Math.random() - 0.5) * 40 };
        ant.targetTime = Date.now() + 2000 + Math.random() * 3000; // 2-5 seconds
      }
    });
  }

  getCategoryLabel(category) {
    const labels = {
      'research': 'Research Paper',
      'project': 'Open Source',
      'blog': 'Blog Post',
      'software': 'Software Project',
      'paper': 'Research Paper'
    };
    return labels[category] || 'Article';
  }

  moveAnt(ant) {
    const now = Date.now();
    
    // Check if ant has a click target
    if (ant.target && now < ant.targetTime) {
      const dx = ant.target.x - ant.x;
      const dy = ant.target.y - ant.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance > 5) {
        const angleToTarget = Math.atan2(dy, dx);
        ant.angle = this.lerp(ant.angle, angleToTarget, 0.15);
        ant.speed = Math.min(ant.speed * 1.1, 2.0); // Speed up towards target
      } else {
        ant.target = null; // Reached target
      }
    } else {
      ant.target = null;
      ant.speed = Math.max(ant.speed * 0.95, 0.3); // Slow back down
      
      if (ant.article) {
        // Ants assigned to articles orbit around them
        const article = ant.article;
        const centerX = article.x + 160;
        const centerY = article.y + 85;
        
        // Calculate orbital position
        ant.targetAngle += 0.01 + Math.random() * 0.02;
        const targetX = centerX + Math.cos(ant.targetAngle) * ant.orbitRadius;
        const targetY = centerY + Math.sin(ant.targetAngle) * ant.orbitRadius;
        
        const dx = targetX - ant.x;
        const dy = targetY - ant.y;
        const angleToOrbit = Math.atan2(dy, dx);
        ant.angle = this.lerp(ant.angle, angleToOrbit, 0.1);
      } else {
        // Free ants wander randomly
        ant.wanderAngle += (Math.random() - 0.5) * 0.3;
        ant.angle = this.lerp(ant.angle, ant.wanderAngle, 0.05);
      }
    }
    
    // Move ant
    ant.x += Math.cos(ant.angle) * ant.speed;
    ant.y += Math.sin(ant.angle) * ant.speed;
    
    // Keep ant on screen with wrapping
    if (ant.x < -10) ant.x = this.width + 10;
    if (ant.x > this.width + 10) ant.x = -10;
    if (ant.y < -10) ant.y = this.height + 10;
    if (ant.y > this.height + 10) ant.y = -10;
    
    // Update ant element
    ant.element.style.left = ant.x + 'px';
    ant.element.style.top = ant.y + 'px';
    ant.element.style.transform = `rotate(${ant.angle}rad)`;
  }


  lerp(a, b, t) {
    // Handle angle wrapping
    let diff = b - a;
    if (diff > Math.PI) diff -= Math.PI * 2;
    if (diff < -Math.PI) diff += Math.PI * 2;
    return a + diff * t;
  }

  animate() {
    // Update clicked points
    this.clickedPoints = this.clickedPoints.filter(point => {
      point.strength *= point.decay;
      return point.strength > 0.01;
    });
    
    // Move article ants
    this.ants.forEach(ant => this.moveAnt(ant));
    
    // Move free-roaming ants
    this.freeAnts.forEach(ant => this.moveAnt(ant));
    
    // Update article positions from DOM (articles are stationary in flex grid)
    this.updateArticlePositions();
    
    // Continue animation
    requestAnimationFrame(() => this.animate());
  }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  new AntColony();
});
</script>

</body>
</html> 