<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>antifold - Computational Explorations in Neural Networks and Consciousness</title>
    <meta name="description" content="Interactive simulations and research exploring neural networks, evolutionary computation, and consciousness through computational experiments.">
    <link rel="stylesheet" href="style.css">
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1 class="site-title">antifold</h1>
            <p class="site-subtitle">Computational explorations in neural networks, evolution, and consciousness</p>
            <nav class="nav">
                <a href="https://github.com/amazedsaint">GitHub</a>
                <a href="https://twitter.com/amazedsaint">Twitter</a>
            </nav>
        </header>

        <main>
            <!-- Featured Theory Article (Newest) -->
            <section class="featured-simulation">
                <div class="simulation-header">
                    <span class="simulation-category">Interactive Theory</span>
                    <h2 class="simulation-title">Nature's Algorithms: Topology-Inspired Visualizations</h2>
                    <p class="simulation-description">
                        Discover how ants and flies have been solving million-dollar computer science problems for millions of years. 
                        Watch digital insects demonstrate fundamental algorithms: symmetry groups, manifold navigation, quantum tunneling, 
                        and message passing that power everything from GPS to neural networks.
                    </p>
                    <div class="simulation-meta">
                        <span>August 9, 2025</span>
                        <span>‚Ä¢</span>
                        <span>Interactive Demonstrations</span>
                        <span>‚Ä¢</span>
                        <span>Topology & Algorithms</span>
                        <span>‚Ä¢</span>
                        <span>Mathematical Visualizations</span>
                    </div>
                    <div class="simulation-actions">
                        <a href="posts/topology-inspired-visualisation-article.html" class="btn-primary">
                            üßÆ Explore Interactive Demos
                        </a>
                    </div>
                </div>
            </section>

            <!-- Featured Research with Simulation -->
            <section class="featured-simulation">
                <div class="simulation-header">
                    <span class="simulation-category">Interactive Research</span>
                    <h2 class="simulation-title">Physics Aware Flies: SE(3) Group Dynamics</h2>
                    <p class="simulation-description">
                        Experience how symmetry, noise, and reward shape motion when agents evolve on Lie groups rather than vector spaces. 
                        This interactive simulation demonstrates generative dynamics on SE(3), where each agent samples on-manifold increments 
                        while a GAN-like critic shapes behavior through user-placed attractors, repellents, and diffusing plumes.
                    </p>
                    <div class="simulation-meta">
                        <span>August 28, 2024</span>
                        <span>‚Ä¢</span>
                        <span>Interactive 3D Simulation</span>
                        <span>‚Ä¢</span>
                        <span>SE(3) Lie Groups</span>
                        <span>‚Ä¢</span>
                        <span>Research Article</span>
                    </div>
                    <div class="simulation-actions">
                        <a href="posts/physics-aware-flies-simulation.html" class="btn-primary">
                            üéÆ Launch Interactive Simulation
                        </a>
                        <a href="posts/physics-aware-flies-article.html" class="btn-secondary">
                            üìñ Read Research Article
                        </a>
                    </div>
                </div>
            </section>
        </main>

        <footer class="footer">
            <p>&copy; 2024 antifold ‚Ä¢ Computational explorations in consciousness</p>
            <p style="margin-top: 8px;"><a href="https://twitter.com/amazedsaint" style="color: #667eea; text-decoration: none; font-weight: 600;">Follow me on ùïè (Twitter)</a></p>
        </footer>
    </div>

    <!-- Ant Animation Canvas -->
    <canvas id="antCanvas" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 1;"></canvas>

    <script>
    // Physics-based ant animation
    class Ant {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.vx = (Math.random() - 0.5) * 0.5;
            this.vy = (Math.random() - 0.5) * 0.5;
            this.angle = Math.atan2(this.vy, this.vx);
            this.size = 8 + Math.random() * 4;
            this.speed = 0.3 + Math.random() * 0.4;
            this.wanderAngle = 0;
            this.opacity = 0.3 + Math.random() * 0.4;
            this.bodyLength = this.size * 1.2;
            this.legPhase = Math.random() * Math.PI * 2;
            this.antennaePhase = Math.random() * Math.PI * 2;
            
            // Avoidance behavior
            this.avoidRadius = 100;
            this.separationRadius = 30;
        }
        
        update(ants, mouseX, mouseY) {
            // Mouse avoidance
            const mouseDistance = Math.sqrt((this.x - mouseX) ** 2 + (this.y - mouseY) ** 2);
            if (mouseDistance < this.avoidRadius && mouseDistance > 0) {
                const avoidStrength = (this.avoidRadius - mouseDistance) / this.avoidRadius * 0.02;
                const avoidAngle = Math.atan2(this.y - mouseY, this.x - mouseX);
                this.vx += Math.cos(avoidAngle) * avoidStrength;
                this.vy += Math.sin(avoidAngle) * avoidStrength;
            }
            
            // Separation from other ants
            let separationX = 0;
            let separationY = 0;
            let separationCount = 0;
            
            for (let other of ants) {
                if (other !== this) {
                    const distance = Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);
                    if (distance < this.separationRadius && distance > 0) {
                        separationX += (this.x - other.x) / distance;
                        separationY += (this.y - other.y) / distance;
                        separationCount++;
                    }
                }
            }
            
            if (separationCount > 0) {
                separationX /= separationCount;
                separationY /= separationCount;
                this.vx += separationX * 0.01;
                this.vy += separationY * 0.01;
            }
            
            // Wandering behavior
            this.wanderAngle += (Math.random() - 0.5) * 0.2;
            this.vx += Math.cos(this.wanderAngle) * 0.005;
            this.vy += Math.sin(this.wanderAngle) * 0.005;
            
            // Limit velocity
            const velocity = Math.sqrt(this.vx ** 2 + this.vy ** 2);
            if (velocity > this.speed) {
                this.vx = (this.vx / velocity) * this.speed;
                this.vy = (this.vy / velocity) * this.speed;
            }
            
            // Update position
            this.x += this.vx;
            this.y += this.vy;
            
            // Update angle for drawing
            this.angle = Math.atan2(this.vy, this.vx);
            
            // Wrap around screen
            if (this.x < -20) this.x = window.innerWidth + 20;
            if (this.x > window.innerWidth + 20) this.x = -20;
            if (this.y < -20) this.y = window.innerHeight + 20;
            if (this.y > window.innerHeight + 20) this.y = -20;
            
            // Update animation phases
            this.legPhase += 0.3;
            this.antennaePhase += 0.2;
        }
        
        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);
            ctx.globalAlpha = this.opacity;
            
            // Ant body color - subtle brown/black
            ctx.fillStyle = 'rgba(60, 40, 30, 0.8)';
            ctx.strokeStyle = 'rgba(40, 25, 15, 0.9)';
            ctx.lineWidth = 1;
            
            // Main body segments
            // Head
            ctx.beginPath();
            ctx.ellipse(-this.size * 0.8, 0, this.size * 0.4, this.size * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Thorax
            ctx.beginPath();
            ctx.ellipse(-this.size * 0.2, 0, this.size * 0.35, this.size * 0.25, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Abdomen
            ctx.beginPath();
            ctx.ellipse(this.size * 0.5, 0, this.size * 0.6, this.size * 0.4, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Antennae
            ctx.strokeStyle = 'rgba(40, 25, 15, 0.7)';
            ctx.lineWidth = 1;
            
            const antennaeSway = Math.sin(this.antennaePhase) * 0.3;
            ctx.beginPath();
            ctx.moveTo(-this.size * 0.8, 0);
            ctx.lineTo(-this.size * 1.2, -this.size * 0.3 + antennaeSway);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(-this.size * 0.8, 0);
            ctx.lineTo(-this.size * 1.2, this.size * 0.3 - antennaeSway);
            ctx.stroke();
            
            // Legs - animated walking
            ctx.lineWidth = 1.5;
            const legOffset = Math.sin(this.legPhase) * 0.2;
            
            // Left legs
            for (let i = 0; i < 3; i++) {
                const legX = -this.size * 0.5 + i * this.size * 0.4;
                const legY = -this.size * 0.4 - legOffset * (i % 2 === 0 ? 1 : -1);
                ctx.beginPath();
                ctx.moveTo(legX, 0);
                ctx.lineTo(legX - this.size * 0.2, legY);
                ctx.stroke();
            }
            
            // Right legs
            for (let i = 0; i < 3; i++) {
                const legX = -this.size * 0.5 + i * this.size * 0.4;
                const legY = this.size * 0.4 + legOffset * (i % 2 === 0 ? 1 : -1);
                ctx.beginPath();
                ctx.moveTo(legX, 0);
                ctx.lineTo(legX - this.size * 0.2, legY);
                ctx.stroke();
            }
            
            ctx.restore();
        }
    }
    
    // Animation setup
    const canvas = document.getElementById('antCanvas');
    const ctx = canvas.getContext('2d');
    let ants = [];
    let mouseX = -1000;
    let mouseY = -1000;
    
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    
    // Initialize ants
    function initAnts() {
        ants = [];
        const antCount = Math.min(12, Math.floor(window.innerWidth / 100)); // Responsive ant count
        
        for (let i = 0; i < antCount; i++) {
            const x = Math.random() * window.innerWidth;
            const y = Math.random() * window.innerHeight;
            ants.push(new Ant(x, y));
        }
    }
    
    // Mouse tracking
    document.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
    });
    
    // Touch tracking for mobile
    document.addEventListener('touchmove', (e) => {
        if (e.touches.length > 0) {
            mouseX = e.touches[0].clientX;
            mouseY = e.touches[0].clientY;
        }
    });
    
    // Hide mouse influence when not on page
    document.addEventListener('mouseleave', () => {
        mouseX = -1000;
        mouseY = -1000;
    });
    
    // Animation loop
    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Update and draw ants
        for (let ant of ants) {
            ant.update(ants, mouseX, mouseY);
            ant.draw(ctx);
        }
        
        requestAnimationFrame(animate);
    }
    
    // Initialize
    resizeCanvas();
    initAnts();
    animate();
    
    // Handle window resize
    window.addEventListener('resize', () => {
        resizeCanvas();
        initAnts(); // Reinitialize ants for new screen size
    });
    </script>

</body>
</html>